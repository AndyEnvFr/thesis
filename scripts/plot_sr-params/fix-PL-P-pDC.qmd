---
title: "PhyloSim Changes"
author: "A.I."
format:
  html:
    number-sections: true
editor: visual
---

```{r}
#| warning: false
library(PhyloSim)
library(parallel)
library(dplyr)
library(tidyverse)
library(lattice)
library(ggplot2)
library(metafor)
library(MASS)
library(viridis)
# root <- "~/Uni/Master/MA/" # work from local machine
root <- "~/cyber_synch/" # work from uni bayreuth server
```

**Here, I plot the effects of N, NL, nDC while all P properties are fixed**

## Data preparation

```{r}
#| eval: false

# load in runs with exp kernel
runsRaw  <- readRDS(paste0(root, "/local/runs/plot_sr-params/mat/fix-PL-P-pDC.rds"))
```

```{r}
#| eval: false

# get conspecific neighbors and proper naming
runsRaw  <- getConNeigh(runsRaw, radius = 5)
```

```{r}
saveRDS(runsRaw, paste0(root, "/local/runs/plot_sr-params/temp/fix-PL-P-pDC_conMax.rds"))
runsRaw  <- readRDS(paste0(root, "/local/runs/plot_sr-params/temp/fix-PL-P-pDC_conMax.rds"))
```

```{r}
# make the runs more slim
# runs_ix <- lapply(runsRaw, function(x){
#   x$Output <- x$Output[101:300]
#   return(x)
# })
```

```{r}
namesShort <- names(runsRaw) %>%
  stringr::str_remove("_disp.+") %>% 
  stringr::str_replace("Cut", "-C") %>% 
  stringr::str_replace("Cut", "-C") %>% 
  stringr::str_replace("pdd", "P") %>% 
  stringr::str_replace("ndd", "N") %>% 
  stringr::str_replace_all("Var", "-L")

```

```{r}
names(runsRaw) <- namesShort
```

```{r}
S <- getSpecTime(runsRaw, plot = FALSE)
```

```{r}
# Extract mean and sd of species richness
Sp <- sapply(S, function(x){
  vals <- x$spec_rich[99:200]
  c(mean = mean(vals), sd = sd(vals))
}) %>% t() %>% as.data.frame()
colnames(Sp) <- c("meanSR", "sdSR")
Sp$params <- namesShort 

# Parse parameters correctly (nDD: N, NL, C)
Sp2 <- Sp %>%
  extract(params,
          into = c("N","NL","C"),
          regex = "N([0-9.]+)-L([0-9.]+)-C([0-9]+)",
          remove = FALSE) %>%
  mutate(N  = as.numeric(N),
         NL = as.numeric(NL),
         C  = as.numeric(C))

# Get the N=0 baseline (only exists for NL=20)
base0 <- Sp2 %>% filter(N == 0, NL == 20)

# All NL values present in the data
all_NL <- sort(unique(Sp2$NL))

# For each C value, replicate the N=0 point across all NL values
base0_expanded <- do.call(rbind, lapply(unique(base0$C), function(c_val) {
  base_c <- base0[base0$C == c_val, ]
  expanded <- base_c[rep(1, length(all_NL)), ]
  expanded$NL <- all_NL
  expanded$params <- paste0("N0-L", all_NL, "-C", c_val, "_N1-L5-C1")
  return(expanded)
}))

# Remove the original N=0, NL=20 entries to avoid duplicates
Sp2_filtered <- Sp2 %>% filter(!(N == 0 & NL == 20))

# Bind expanded baseline back, neutralize sdSR for replicated rows
Sp2_final <- bind_rows(Sp2_filtered, base0_expanded) %>% 
  mutate(sdSR = case_when(
    N == 0 & NL != 20 ~ NA_real_,
    TRUE ~ sdSR
  ))

```

```{r}
#| fig-width: 10
#| fig-height: 5


# Create the baseline point for each C value
baseline_unique <- Sp2_final %>% 
  filter(N == 0 & NL == 20) %>%
  group_by(C) %>%
  slice(1) %>%
  ungroup()

# Create complete dataset including baseline for lines
# but keep separate datasets for different point styling
complete_data <- Sp2_final %>% filter(N > 0)

# Plot
plotNDD <- ggplot() +
  # Plot lines connecting all points (including baseline)
  geom_line(data = Sp2_final, 
            aes(x = N, y = meanSR, color = factor(NL), group = NL), 
            size = .8) +
  # Plot colored points for N > 0
  geom_point(data = complete_data, 
             aes(x = N, y = meanSR, color = factor(NL)), 
             size = 2, position = position_dodge(width = 0.1)) +
  geom_errorbar(data = complete_data,
                aes(x = N, y = meanSR, color = factor(NL),
                    ymin = meanSR - sdSR, ymax = meanSR + sdSR),
                width = 0.05, alpha = 1,
                position = position_dodge(width = 0.075)) +
  # Add the baseline points in black (this will overlay the colored points at N=0)
  geom_point(data = baseline_unique, 
             aes(x = N, y = meanSR), 
             color = "black", size = 2, shape = 3) +
  geom_errorbar(data = baseline_unique,
                aes(x = N, y = meanSR, ymin = meanSR - sdSR, ymax = meanSR + sdSR),
                color = "black", width = 0.005, alpha = 1) +
  facet_wrap(~ C, ncol = 3, scales = "fixed",
             labeller = labeller(C = function(x) paste("nDD kernel =", x))) +
  labs(x = "nDD strength",
       y = "mean species richness",
       color = "nDD\nspecificity") +
  theme_classic(base_size = 16) +
  theme(
    strip.background = element_blank(),
    legend.position = "right",
    strip.text = element_text(size = 15, margin = margin(b = -20)),
    plot.margin = margin(20, 20, 20, 20),
    panel.spacing = unit(1, "lines"),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    panel.grid.major.y = element_line(color = "grey90", size = 0.2),
    panel.grid.minor.y = element_line(color = "grey95", size = 0.2),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank()
  ) + 
  coord_cartesian(clip = "off") +
  scale_color_viridis_d(option = "plasma") +
  scale_x_continuous(breaks = seq(0, 1, by = 0.2))

print(plotNDD)
```

```{r}
# pdf(paste0(root, "local/figures/plot_sr-params/nddEffect.pdf"), width = 10, height = 5, onefile = TRUE, useDingbats = FALSE)
print(plotNDD)
# dev.off()
```

Next, we convert the matrix data into tabular data. With the argument detailedParams we include the parameter settings a seperate cols. We save the tabular data.

```{r}
#| eval: false


# reduce size of data by burn in period until equilibrium is reached
runsFilt <- lapply(runsRaw, function(x){
  x$Output <- x$Output[99:200]
  x$Model$runs <- x$Model$runs[99:200]
  return(x)
})

# convert matrices to tabular data. This is done parallel, as it takes longer
cl <- makeCluster(length(runsFilt)/2)
clusterExport(cl, c("getMatToTab", "runsFilt"))
tab <- parLapply(cl = cl, X = runsFilt, fun = function(x) getMatToTab(x, detailedParams = TRUE))

saveRDS(tab, paste0(root, "local/runs/plot_sr-params/tab/fix-P-PL-pDCMax.rds"))
```

```{r}
# tab <- readRDS(paste0(root, "local/runs/plot_sr-params/tab/fix-P-PL-pDC.rds"))
tab <- readRDS(paste0(root, "local/runs/plot_sr-params/tab/fix-P-PL-pDCMax.rds"))
```

```{r}
# keep only first timespot in census

cores <- length(tab) / 2
cl <- makeCluster(30)

clusterEvalQ(cl, {
  library(dplyr)
})

tabS <- parLapply(cl, tab, function(x) {
  x %>%
    filter(abund > 100) %>%
    mutate(specIdCen = paste0(specId, census)) %>%
    select(-indId)
})

stopCluster(cl)
```

### Metafor analysis: correcting for uncertainty

```{r}
#| eval: false

cl <- makeCluster(length(tabS)/2)
clusterEvalQ(cl, {
  library(PhyloSim)
})
mcS_err <- parLapply(cl, tabS, function(x) {
  specIDs <- unique(x$specIdCen)
  res <- vector("list", length(specIDs))
  
  i <- 1
  for (sID in specIDs) {
    dat <- x[x$specIdCen == sID, ]
    mod <- glm(mortNextGen ~ con, data = dat, family = binomial())
    sfm <- summary(mod)$coefficients
    # corFac <- nrow(getCircularOffsets(max(x$pDC, x$nDC))) / 4
    vc <- vcov(mod)[c("(Intercept)", "con"), c("(Intercept)", "con")] # * corFac # correction factor

    mort0 <- plogis(coef(mod)[1])
    mort1 <- plogis(coef(mod)[1] + coef(mod)[2]) # * corFac) # correction factor
    
    res[[i]] <- list(
      specId = sID,
      abund = dat$abund[1],
      mort_change = mort1 - mort0,
      coef = coef(mod)[c(1,2)], # * c(1, corFac), # correction factor
      vcov = vc
    )
    i <- i + 1
  }
  return(res)
})

# Stop the cluster
stopCluster(cl)
```

## compute variance of the marginal effect through a "posterior" simulation

```{r}
#| eval: false

cl <- makeCluster(length(mcS_err) / 2)
mcS_err_sim <- parLapply(cl, mcS_err, function(x){
  lapply(x, function(y){
    sim <- MASS::mvrnorm(n = 100, mu = c(y$coef[1], y$coef[2]), Sigma = y$vcov)
    mort0 <- plogis(sim[, 1])
    mort1 <- plogis(sim[, 1] + sim[, 2])
    mort_diff <- mort1 - mort0
    
    return(data.frame(
      abund = y$abund,
      specId = y$specId,
      mean = mean(mort_diff),
      se = sd(mort_diff),
      ci_low = quantile(mort_diff, 0.025),
      ci_high = quantile(mort_diff, 0.975)
    ))
  })
})
# Stop the cluster
stopCluster(cl)
```

## unlist inner lists and add log abund

```{r}
#| eval: false

m4 <- lapply(mcS_err_sim, function(group) {
  do.call(rbind, group)
})

m4 <- lapply(m4, function(group) {
  row.names(group) <- NULL
  group <- group %>% 
    mutate(log_N = log(abund))
  return(group)
})
```

## fitting model

```{r}
#| eval: false

dat_meta <- lapply(m4, function(x) {
  escalc(measure = "GEN", yi = mean, sei = se, slab = specId, data = x)
})
```

```{r}
#| eval: false

# # Detect available cores and create a cluster
# cl <- makeCluster(length(dat_meta))
# 
# # Export needed objects and packages to the workers
# clusterExport(cl, varlist = c("dat_meta"), envir = environment())
# 
# # Run in parallel
# metamod <- parLapply(cl, dat_meta, function(x) {
#   metafor::rma(
#     yi = yi,
#     vi = vi,
#     mods = ~ log_N,
#     method = "REML",
#     data = x
#   )
# })
# 
# # Stop cluster
# stopCluster(cl)
# 
# names(metamod) <- namesShort
```

```{r}
cl <- makeCluster(length(dat_meta) / 2)
clusterExport(cl, varlist = c("dat_meta"), envir = environment())

metamod <- parLapply(cl, dat_meta, function(x) {
  tryCatch({
    metafor::rma(
      yi = yi,
      vi = vi,
      mods = ~ log_N,
      method = "REML",
      data = x
    )
  }, error = function(e) {
    return(NULL)  # Return NULL for failed models
  })
})

stopCluster(cl)

# Remove NULL elements and keep names aligned
failed_indices <- sapply(metamod, is.null)
namesShort <- names(metamod)
metamod <- metamod[!failed_indices]
names(metamod) <- namesShort[!failed_indices]

# Report which models failed
if(any(failed_indices)) {
  cat("Failed models:", paste(namesShort[failed_indices], collapse = ", "), "\n")
}
```

```{r}

# deleting one scenario
# 
# saveRDS(dat_meta, paste0(root, "local/runs/plot_sr-params/metafor/fix-PL-P-pDC_datmetaMax.rds"))
# saveRDS(metamod, paste0(root, "local/runs/plot_sr-params/metafor/fix-PL-P-pDC_metamodMax.rds"))


metamod <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/fix-PL-P-pDC_metamodMax.rds"))
dat_meta <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/fix-PL-P-pDC_datmetaMax.rds"))
namesShort <- names(metamod)

```

## predictions

### log_N

```{r}
#| fig-width: 6
#| fig-height: 6

cb_colors <- c(
  "#029E73",  # Green
  "#0173B2",  # Blue
  "#DE8F05",  # Orange
  "#CC78BC",  # Purple
  "firebrick"   # Brown
)

## --- build predictions (as you had) ---
pred <- lapply(dat_meta, function(x){
  expand_grid(log_N = seq(min(x$log_N, na.rm = TRUE),
                          max(x$log_N, na.rm = TRUE),
                          length.out = 1000))
})
pred <- lapply(pred, function(x){
  x$abund <- exp(x$log_N)
  x
})
pred <- lapply(seq_along(pred), function(i){
  x <- pred[[i]]
  y <- metamod[[i]]
  cbind(x, predict(object = y, newmods = x$log_N))
})
names(pred) <- namesShort

## --- helper: parse N, NL, C from the *second* chunk ---
extract_params <- function(nm) {
  rhs <- sub(".*_", "", nm)                 # "N0.2-L10-C3"
  N  <- as.numeric(sub("N([0-9.]+).*", "\\1", rhs))
  NL <- as.numeric(sub(".*-L([0-9.]+).*", "\\1", rhs))
  C  <- as.numeric(sub(".*-C([0-9.]+)$",   "\\1", rhs))
  data.frame(N = N, NL = NL, C = C)
}

## --- bind list to df with parsed params ---
pred_df_raw <- do.call(rbind, lapply(seq_along(pred), function(i) {
  df <- pred[[i]]
  pars <- extract_params(names(pred)[i])
  df$scenario <- names(pred)[i]
  df$N  <- pars$N
  df$NL <- pars$NL
  df$C  <- pars$C
  df
}))

## --- normalize predict() columns ---
if ("pred" %in% names(pred_df_raw))   names(pred_df_raw)[names(pred_df_raw)=="pred"]   <- "fitted"
if ("fit"  %in% names(pred_df_raw))   names(pred_df_raw)[names(pred_df_raw)=="fit"]    <- "fitted"
if ("ci.lb" %in% names(pred_df_raw))  pred_df_raw$ci_lower <- pred_df_raw$ci.lb
if ("ci.ub" %in% names(pred_df_raw))  pred_df_raw$ci_upper <- pred_df_raw$ci.ub

pred_df <- pred_df_raw %>% filter(N != 0)

## --- null models for each C value ---
null_nameC1 <- "P1-L5-C1_N0-L20-C1"
null_dataC1 <- if (null_nameC1 %in% pred_df_raw$scenario) pred_df_raw[pred_df_raw$scenario == null_nameC1, ] else NULL

null_nameC3 <- "P1-L5-C1_N0-L20-C3"
null_dataC3 <- if (null_nameC3 %in% pred_df_raw$scenario) pred_df_raw[pred_df_raw$scenario == null_nameC3, ] else NULL

null_nameC5 <- "P1-L5-C1_N0-L20-C5"
null_dataC5 <- if (null_nameC5 %in% pred_df_raw$scenario) pred_df_raw[pred_df_raw$scenario == null_nameC5, ] else NULL

## --- CHANGED: build separate plots per (N, C), lines = NL levels ---
library(ggplot2)

# common axes
x_range <- range(pred_df$abund[pred_df$abund > 0 & is.finite(pred_df$abund)], na.rm = TRUE)
y_range <- range(c(pred_df$ci_lower, pred_df$ci_upper), na.rm = TRUE)

# order NL nicely for legend (now NL is color)
pred_df$NL_fac <- factor(pred_df$NL, levels = sort(unique(pred_df$NL)))

# CHANGED: now combinations are N and C
combos <- unique(pred_df[c("N", "C")])
combos <- combos[order(combos$N, combos$C), ]

plots_list <- vector("list", nrow(combos))
names(plots_list) <- paste0("N", combos$N, "_C", combos$C)

for (i in seq_len(nrow(combos))) {
  n_i <- combos$N[i]
  c_i <- combos$C[i]
  dat <- subset(pred_df, N == n_i & C == c_i)
  if (nrow(dat) == 0) next

  p <- ggplot()

  # add appropriate null model
  null_data <- if (c_i == 1) null_dataC1 else if (c_i == 3) null_dataC3 else if (c_i == 5) null_dataC5 else NULL
  
  if (!is.null(null_data)) {
    p <- p +
      geom_ribbon(data = null_data,
                  aes(x = abund, ymin = ci_lower, ymax = ci_upper),
                  alpha = 0.2, fill = "black") +
      geom_line(data = null_data,
                aes(x = abund, y = fitted),
                linetype = "dashed", size = .5, color = "black", alpha = 0.9)
  }

  # CHANGED: treatment lines now colored by NL (specificity)
  p <- p +
    geom_ribbon(data = dat, 
                aes(x = abund, ymin = ci_lower, ymax = ci_upper, fill = NL_fac),
                alpha = 0.1) +
    geom_line(data = dat, 
              aes(x = abund, y = fitted, color = NL_fac), 
              size = 1.2) +
    scale_x_log10(limits = x_range, expand = expansion(mult = 0.02)) +
    labs(title = paste0("nDD strength = ", n_i, ", nDD radius = ", c_i),
         x = "species abundance",
         y = "stabilizing CDD (%)",
         color = "nDD specificity (lambda)",
         fill = "nDD specificity (lambda)") +
    theme_classic(base_size = 14) +
    theme(legend.position = "bottom",
          legend.key.size = unit(0.5, "cm"),
          # legend.text = element_text(size = 10),
          # legend.title = element_text(size = 11),
          plot.title = element_text(size = 14, hjust = 0.5)) +
    scale_color_manual(values = cb_colors) +
    scale_fill_manual(values = cb_colors) +
    coord_cartesian(ylim = c(-0.0004, 0.0010))+ 
        annotate("text",
             x = 3000, y = 0.001,
             label = "pDD fixed at\nstrength = 1\nlambda = 5\nradius = 1",
             hjust = 0, vjust = 1,
             size = 4)

  plots_list[[i]] <- p
}

# Print all plots
sapply(plots_list, print)

```

## save PDF

```{r}
# pdf(paste0(root, "local/figures/plot_sr-params/nddSlopeMax.pdf"), width = 6, height = 6, onefile = TRUE, useDingbats = FALSE)
# sapply(plots_list, print)   # each print() â†’ new page
# dev.off()
```
## plot with only null and schroeder settings

```{r}
metamodNDD <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/fix-PL-P-pDC_metamodMax.rds"))
dat_metaNDD <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/fix-PL-P-pDC_datmetaMax.rds"))
namesShortNDD <- names(metamodNDD)

metamodPDD <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/fix-N-NL-nDC_metamodMax.rds"))
dat_metaPDD <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/fix-N-NL-nDC_datmetaMax.rds"))
namesShortPDD <- names(metamodPDD)

# metamod <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/fix-PL-P-pDC_metamodMax.rds"))
# dat_meta <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/fix-PL-P-pDC_datmetaMax.rds"))
# namesShort <- names(metamod)

# load neutral data too
neutSR <- readRDS(paste0(root, "local/runs/plot_sr-params/neutralSR.rds"))
datmetaNeut <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/datmetaNeut.rds"))
metamodNeut <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/metamodNeut.rds"))
```

```{r}
# get SR for strong nDD and strong pDD runs
pDDS <- readRDS(paste0(root, "local/runs/plot_sr-params/mat/fix-N-NL-nDC.rds"))
nDDS <- readRDS(paste0(root, "local/runs/plot_sr-params/mat/fix-PL-P-pDC.rds"))

pDDSR <- getSpecTime(pDDS, plot = FALSE)
nDDSR <- getSpecTime(nDDS, plot = FALSE)

names(pDDSR) <- names(metamodPDD)
names(nDDSR) <- names(metamodNDD)

pDDSR <- pDDSR[["P1-L20-C5_N1-L5-C1"]] %>% 
  mutate(meanSR = mean(spec_rich),
         sdSR = sd (spec_rich)) %>% 
  dplyr::select(-year, -spec_rich) %>% 
  slice(1)
nDDSR <- nDDSR[["P1-L5-C1_N1-L20-C5"]] %>% 
  mutate(meanSR = mean(spec_rich),
         sdSR = sd (spec_rich)) %>% 
  dplyr::select(-year, -spec_rich) %>% 
  slice(1)
```


```{r}
# append neut data to DD data

dat_metaNDD <- c(dat_metaNDD, list(datmetaNeut))
metamodNDD <- c(metamodNDD, list(metamodNeut))
```

```{r}
namesshort <- names(dat_metaNDD)
namesshort[length(namesshort)] <- "neutral"
```

## plot with only neutral and schroeder settings

care null != neutral
```{r}
#| fig-width: 7
#| fig-height: 6

cb_colors <- c(
  "firebrick",
  "olivedrab"
)

## --- Helper function to extract all params ---
extract_params <- function(nm) {
  # Split by underscore to get both parts
  parts <- strsplit(nm, "_")[[1]]

  # First part: P-PL-PC
  first <- parts[1]
  P  <- as.numeric(sub("P([0-9.]+).*", "\\1", first))
  PL <- as.numeric(sub(".*-L([0-9.]+).*", "\\1", first))
  PC <- as.numeric(sub(".*-C([0-9.]+)$", "\\1", first))

  # Second part: N-NL-NC
  second <- parts[2]
  N  <- as.numeric(sub("N([0-9.]+).*", "\\1", second))
  NL <- as.numeric(sub(".*-L([0-9.]+).*", "\\1", second))
  NC <- as.numeric(sub(".*-C([0-9.]+)$", "\\1", second))

  data.frame(P = P, PL = PL, PC = PC, N = N, NL = NL, NC = NC)
}

## --- Process NDD data ---
pred_ndd <- lapply(dat_metaNDD, function(x){
  expand_grid(log_N = seq(min(x$log_N, na.rm = TRUE),
                          max(x$log_N, na.rm = TRUE),
                          length.out = 1000))
})
pred_ndd <- lapply(pred_ndd, function(x){
  x$abund <- exp(x$log_N)
  x
})
pred_ndd <- lapply(seq_along(pred_ndd), function(i){
  x <- pred_ndd[[i]]
  y <- metamodNDD[[i]]
  cbind(x, predict(object = y, newmods = x$log_N))
})
names(pred_ndd) <- namesshort

pred_df_ndd_raw <- do.call(rbind, lapply(seq_along(pred_ndd), function(i) {
  df <- pred_ndd[[i]]
  pars <- extract_params(names(pred_ndd)[i])
  df$scenario <- names(pred_ndd)[i]
  df$P  <- pars$P
  df$PL <- pars$PL
  df$PC <- pars$PC
  df$N  <- pars$N
  df$NL <- pars$NL
  df$NC <- pars$NC
  df
}))

if ("pred" %in% names(pred_df_ndd_raw))   names(pred_df_ndd_raw)[names(pred_df_ndd_raw)=="pred"]   <- "fitted"
if ("fit"  %in% names(pred_df_ndd_raw))   names(pred_df_ndd_raw)[names(pred_df_ndd_raw)=="fit"]    <- "fitted"
if ("ci.lb" %in% names(pred_df_ndd_raw))  pred_df_ndd_raw$ci_lower <- pred_df_ndd_raw$ci.lb
if ("ci.ub" %in% names(pred_df_ndd_raw))  pred_df_ndd_raw$ci_upper <- pred_df_ndd_raw$ci.ub

## --- Process PDD data ---
pred_pdd <- lapply(dat_metaPDD, function(x){
  expand_grid(log_N = seq(min(x$log_N, na.rm = TRUE),
                          max(x$log_N, na.rm = TRUE),
                          length.out = 1000))
})
pred_pdd <- lapply(pred_pdd, function(x){
  x$abund <- exp(x$log_N)
  x
})
pred_pdd <- lapply(seq_along(pred_pdd), function(i){
  x <- pred_pdd[[i]]
  y <- metamodPDD[[i]]
  cbind(x, predict(object = y, newmods = x$log_N))
})
names(pred_pdd) <- names(dat_metaPDD)

pred_df_pdd_raw <- do.call(rbind, lapply(seq_along(pred_pdd), function(i) {
  df <- pred_pdd[[i]]
  pars <- extract_params(names(pred_pdd)[i])
  df$scenario <- names(pred_pdd)[i]
  df$P  <- pars$P
  df$PL <- pars$PL
  df$PC <- pars$PC
  df$N  <- pars$N
  df$NL <- pars$NL
  df$NC <- pars$NC
  df
}))

if ("pred" %in% names(pred_df_pdd_raw))   names(pred_df_pdd_raw)[names(pred_df_pdd_raw)=="pred"]   <- "fitted"
if ("fit"  %in% names(pred_df_pdd_raw))   names(pred_df_pdd_raw)[names(pred_df_pdd_raw)=="fit"]    <- "fitted"
if ("ci.lb" %in% names(pred_df_pdd_raw))  pred_df_pdd_raw$ci_lower <- pred_df_pdd_raw$ci.lb
if ("ci.ub" %in% names(pred_df_pdd_raw))  pred_df_pdd_raw$ci_upper <- pred_df_pdd_raw$ci.ub
## --- ------ ------ ------ ------ ------ ---

# nDD treatment: P=1, PL=5, PC=1, N=1, NL=20, NC=5
ndd_data <- pred_df_ndd_raw[pred_df_ndd_raw$P == 1 & pred_df_ndd_raw$PL == 5 &
                             pred_df_ndd_raw$PC == 1 & pred_df_ndd_raw$N == 1 &
                             pred_df_ndd_raw$NL == 20 & pred_df_ndd_raw$NC == 5, ]
# pDD treatment: P=1, PL=5, PC=1, N=1, NL=20, NC=5
pdd_data <- pred_df_pdd_raw[pred_df_pdd_raw$P == 1 & pred_df_pdd_raw$PL == 20 &
                             pred_df_pdd_raw$PC == 5 & pred_df_pdd_raw$N == 1 &
                             pred_df_pdd_raw$NL == 5 & pred_df_pdd_raw$NC == 1, ]

neut_data <- pred_df_ndd_raw[pred_df_ndd_raw$scenario == "neutral", ]

# Combine data and add labels
neut_data$treatment <- "neutral run"
ndd_data$treatment <- "high nDD"
pdd_data$treatment <- "high pDD"

combined_data <- rbind(
  neut_data[, c("abund", "fitted", "ci_lower", "ci_upper", "treatment")],
  ndd_data[, c("abund", "fitted", "ci_lower", "ci_upper", "treatment")],
  pdd_data[, c("abund", "fitted", "ci_lower", "ci_upper", "treatment")]
)

combined_data$treatment <- factor(combined_data$treatment,
                                   levels = c("neutral run",
                                             "high pDD",
                                             "high nDD"))

x_range <- range(combined_data$abund[combined_data$abund > 0], na.rm = TRUE)

p <- ggplot(combined_data, aes(x = abund, y = fitted,
                                color = treatment,
                                fill = treatment,
                                linetype = treatment)) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2, color = NA) +
  geom_line(size = 1.2) +
  scale_x_log10(limits = x_range, expand = expansion(mult = 0.02)) +
  scale_color_manual(values = c("darkgrey", "olivedrab3", "firebrick")) +
  scale_fill_manual(values = c("darkgrey", "olivedrab3", "firebrick")) +
  scale_linetype_manual(values = c("dashed", "solid", "solid")) +
  labs(title = "",
       x = "species abundance",
       y = "stabilizing CDD (%)",
       color = "Treatment",
       fill = "Treatment",
       linetype = "Treatment") +
  theme_classic(base_size = 14) +
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        plot.title = element_text(size = 14, hjust = 0.5)) +
  coord_cartesian(ylim = c(-0.0005, 0.0010))  +
  guides(color = guide_legend(reverse = TRUE),
         fill = guide_legend(reverse = TRUE),
         linetype = guide_legend(reverse = TRUE)) +
          annotate("text",
             x = 2500, y = 0.001,
             label = "mean species\nrichness ",
             hjust = 0, vjust = 1,
             size = 5) +
          annotate("text",
             x = 2500, y = 0.00055,
             label = round(neutSR$meanSR,2),
             hjust = 0, vjust = 1,
             size = 5, col = "darkgrey") +
          annotate("text",
             x = 2500, y = 0.00075,
             label = round(nDDSR$meanSR,2),
             hjust = 0, vjust = 1,
             size = 5,col = "firebrick") +
          annotate("text",
             x = 2500, y = 0.00065,
             label = round(pDDSR$meanSR,2),
             hjust = 0, vjust = 1,
             size = 5, col = "olivedrab3")
print(p)
```
```{r}
# pdf(paste0(root, "local/figures/plot_sr-params/paramSchroed.pdf"), width = 6, height = 6, onefile = TRUE, useDingbats = FALSE)
# print(p)
# dev.off()
```
```{r}
#| fig-width: 7
#| fig-height: 6

## --- Helper function to extract all params ---
extract_params <- function(nm) {
  # Split by underscore to get both parts
  parts <- strsplit(nm, "_")[[1]]

  # First part: P-PL-PC
  first <- parts[1]
  P  <- as.numeric(sub("P([0-9.]+).*", "\\1", first))
  PL <- as.numeric(sub(".*-L([0-9.]+).*", "\\1", first))
  PC <- as.numeric(sub(".*-C([0-9.]+)$", "\\1", first))

  # Second part: N-NL-NC
  second <- parts[2]
  N  <- as.numeric(sub("N([0-9.]+).*", "\\1", second))
  NL <- as.numeric(sub(".*-L([0-9.]+).*", "\\1", second))
  NC <- as.numeric(sub(".*-C([0-9.]+)$", "\\1", second))

  data.frame(P = P, PL = PL, PC = PC, N = N, NL = NL, NC = NC)
}

## --- Process NDD data ---
pred_ndd <- lapply(dat_metaNDD, function(x){
  expand_grid(log_N = seq(min(x$log_N, na.rm = TRUE),
                          max(x$log_N, na.rm = TRUE),
                          length.out = 1000))
})
pred_ndd <- lapply(pred_ndd, function(x){
  x$abund <- exp(x$log_N)
  x
})
pred_ndd <- lapply(seq_along(pred_ndd), function(i){
  x <- pred_ndd[[i]]
  y <- metamodNDD[[i]]
  cbind(x, predict(object = y, newmods = x$log_N))
})
names(pred_ndd) <- namesshort

pred_df_ndd_raw <- do.call(rbind, lapply(seq_along(pred_ndd), function(i) {
  df <- pred_ndd[[i]]
  pars <- extract_params(names(pred_ndd)[i])
  df$scenario <- names(pred_ndd)[i]
  df$P  <- pars$P
  df$PL <- pars$PL
  df$PC <- pars$PC
  df$N  <- pars$N
  df$NL <- pars$NL
  df$NC <- pars$NC
  df
}))

if ("pred" %in% names(pred_df_ndd_raw))   names(pred_df_ndd_raw)[names(pred_df_ndd_raw)=="pred"]   <- "fitted"
if ("fit"  %in% names(pred_df_ndd_raw))   names(pred_df_ndd_raw)[names(pred_df_ndd_raw)=="fit"]    <- "fitted"
if ("ci.lb" %in% names(pred_df_ndd_raw))  pred_df_ndd_raw$ci_lower <- pred_df_ndd_raw$ci.lb
if ("ci.ub" %in% names(pred_df_ndd_raw))  pred_df_ndd_raw$ci_upper <- pred_df_ndd_raw$ci.ub


# nDD treatment: P=1, PL=5, PC=1, N=1, NL=20, NC=5
ndd_data <- pred_df_ndd_raw[pred_df_ndd_raw$P == 1 & pred_df_ndd_raw$PL == 5 &
                             pred_df_ndd_raw$PC == 1 & pred_df_ndd_raw$N == 1 &
                             pred_df_ndd_raw$NL == 20 & pred_df_ndd_raw$NC == 5, ]

neut_data <- pred_df_ndd_raw[pred_df_ndd_raw$scenario == "neutral", ]

# Combine data and add labels
neut_data$treatment <- "neutral run"
ndd_data$treatment <- "Schroeder scenario"

combined_data <- rbind(
  neut_data[, c("abund", "fitted", "ci_lower", "ci_upper", "treatment")],
  ndd_data[, c("abund", "fitted", "ci_lower", "ci_upper", "treatment")]
)

combined_data$treatment <- factor(combined_data$treatment,
                                   levels = c("neutral run",
                                             "Schroeder scenario"))

x_range <- range(combined_data$abund[combined_data$abund > 0], na.rm = TRUE)

pp <- ggplot(combined_data, aes(x = abund, y = fitted,
                                color = treatment,
                                fill = treatment,
                                linetype = treatment)) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2, color = NA) +
  geom_line(size = 1.2) +
  scale_x_log10(limits = x_range, expand = expansion(mult = 0.02)) +
  scale_color_manual(values = c("darkgrey", "firebrick")) +
  scale_fill_manual(values = c("darkgrey", "firebrick")) +
  scale_linetype_manual(values = c("dashed", "solid")) +
  labs(title = "",
       x = "species abundance",
       y = "stabilizing CDD (%)",
       color = "Treatment",
       fill = "Treatment",
       linetype = "Treatment") +
  theme_classic(base_size = 14) +
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        plot.title = element_text(size = 14, hjust = 0.5)) +
  coord_cartesian(ylim = c(-0.0005, 0.0010))  +
  guides(color = guide_legend(reverse = TRUE),
         fill = guide_legend(reverse = TRUE),
         linetype = guide_legend(reverse = TRUE)) +
          annotate("text",
             x = 1000, y = 0.001,
             label = "mean species\nrichness ",
             hjust = 0, vjust = 1,
             size = 5) +
          annotate("text",
             x = 1000, y = 0.00065,
             label = round(neutSR$meanSR,2),
             hjust = 0, vjust = 1,
             size = 6, col = "darkgrey") +
          annotate("text",
             x = 1000, y = 0.00075,
             label = format(round(nDDSR$meanSR, 1), nsmall = 2),
             hjust = 0, vjust = 1,
             size = 6,col = "firebrick")
print(pp)
```
```{r}
pdf(paste0(root, "local/figures/plot_sr-params/paramSchroedOnly.pdf"), width = 6, height = 6, onefile = TRUE, useDingbats = FALSE)
print(pp)
dev.off()
```


# compare correlation (slope) with max species abundance and SR
```{r}
datmeta <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/fix-PL-P-pDC_datmetaMax.rds"))
metamod <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/fix-PL-P-pDC_metamodMax.rds"))
runs <- readRDS(paste0(root, "local/runs/plot_sr-params/mat/fix-PL-P-pDC.rds"))

# load neutral data too
neutSR <- readRDS(paste0(root, "local/runs/plot_sr-params/neutralSR.rds"))
datmetaNeut <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/datmetaNeut.rds"))
metamodNeut <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/metamodNeut.rds"))
```

```{r}
# append neut data to DD data

datmeta <- c(datmeta, list(datmetaNeut))
metamod <- c(metamod, list(metamodNeut))
```


```{r}
namesShort <- names(datmeta) %>%
  stringr::str_remove("_disp.+") %>% 
  stringr::str_replace("Cut", "-C") %>% 
  stringr::str_replace("Cut", "-C") %>% 
  stringr::str_replace("pdd", "P") %>% 
  stringr::str_replace("ndd", "N") %>% 
  stringr::str_replace_all("Var", "-L")

namesShort[length(namesShort)] <- "neutral"

pred <- lapply(datmeta, function(x){
  expand_grid(log_N = seq(min(x$log_N, na.rm = TRUE),
                          max(x$log_N, na.rm = TRUE),
                          length.out = 1000))
})
pred <- lapply(pred, function(x){
  x$abund <- exp(x$log_N)
  x
})
pred <- lapply(seq_along(pred), function(i){
  x <- pred[[i]]
  y <- metamod[[i]]
  cbind(x, predict(object = y, newmods = x$log_N))
})
names(pred) <- namesShort   # <- your vector like the one you listed

## --- helper: parse N, NL, C from the *second* chunk (ignore P-part) ---
extract_params <- function(nm) {
  # expect "P1-L5-C1_N0.2-L10-C3"
  rhs <- sub(".*_", "", nm)                 # "N0.2-L10-C3"
  N  <- as.numeric(sub("N([0-9.]+).*", "\\1", rhs))
  NL <- as.numeric(sub(".*-L([0-9.]+).*", "\\1", rhs))
  C  <- as.numeric(sub(".*-C([0-9.]+)$",   "\\1", rhs))
  data.frame(N = N, NL = NL, C = C)
}

## --- bind list to df with parsed params ---
pred_df_raw <- do.call(rbind, lapply(seq_along(pred), function(i) {
  df <- pred[[i]]
  pars <- extract_params(names(pred)[i])
  df$scenario <- names(pred)[i]
  df$N  <- pars$N
  df$NL <- pars$NL
  df$C  <- pars$C
  df
}))


# get slopes
slope <- sapply(metamod, function(x){
  ret <- coef(x)[2]
  return(ret)
})
res <- as.data.frame(slope)
rownames(res) <- namesShort

# get intercept
int <- sapply(metamod, function(x){
  ret <- coef(x)[1]
  return(int = ret)
})
int <- data.frame(
  param = namesShort,
  int = int
)

# get abundance: use max to exclude extremely high values
abund <- sapply(datmeta, function(x){
  return(max(x = x$abund))
})
abund <- data.frame(
  param = names(datmeta),
  abund = abund
)

# get CV of each scenario
cv <- sapply(pred, function(x){
  c(meanMC = mean(x$pred), sdMC = sd(x$pred), rangeMC = diff(range(x$pred)))
}) %>%
  t() %>%
  as.data.frame() %>%
  mutate(cvMC = sdMC / meanMC) %>%
  rownames_to_column("param")

# get sr and rename
srRaw <- getSpecTime(runs, plot = FALSE)
sr <- sapply(srRaw, function(x) {
  vals <- x$spec_rich[99:200]
  c(meanSR = mean(vals), sdSR = sd(vals), medianSR = median(vals))
}) %>% t() %>% as.data.frame()
sr <- rbind(sr,c(neutSR$meanSR, neutSR$sdSR, NA))
rownames(sr) <- namesShort

# combine all results
res <- res %>% 
  rownames_to_column("param") %>% 
  left_join(
    sr %>% 
      rownames_to_column("param"),
    by = "param"
  ) %>% 
  left_join(
    abund, by = "param"
  ) %>% 
  left_join(
    int, by = "param"
  ) %>% 
  mutate(medianSR = as.integer(medianSR),
         abund = as.integer(abund)) %>% 
  left_join(cv, by = "param")

rownames(res) <- namesShort

# Parse the param column to extract N, NL, and C values
res_parsed <- res %>%
  # Split the param column at the underscore to get the two parts
  separate(param, into = c("part1", "part2"), sep = "_", remove = FALSE) %>%
  # Extract N, NL, C from first part (P1-L5-C1 format)
  extract(part1, into = c("P1", "L1", "C1"), regex = "P([0-9]+)-L([0-9]+)-C([0-9]+)", remove = FALSE) %>%
  # Extract N, NL, C from second part (N0-L20-C1 format)
  extract(part2, into = c("N", "NL", "C"), regex = "N([0-9.]+)-L([0-9.]+)-C([0-9]+)", remove = FALSE) %>%
  # Convert to numeric
  mutate(
    N = as.numeric(N),
    NL = as.numeric(NL),
    C = as.numeric(C)
  ) #%>%
  # Remove the temporary columns we don't need
  # select(-part1, -part2, -P1, -L1, -C1)

# Check the parsed data
print("Parsed data structure:")
print(head(res_parsed))

# Get the N=0 baseline (assuming it exists for NL=20)
base0 <- res_parsed %>% filter(N == 0, NL == 20)

# All NL values present in the data
all_NL <- sort(unique(res_parsed$NL))

# For each C value, replicate the N=0 point across all NL values if needed
if(nrow(base0) > 0) {
  base0_expanded <- do.call(rbind, lapply(unique(base0$C), function(c_val) {
    base_c <- base0[base0$C == c_val, ]
    expanded <- base_c[rep(1, length(all_NL)), ]
    expanded$NL <- all_NL
    return(expanded)
  }))
  
  # Remove the original N=0, NL=20 entries to avoid duplicates
  res_filtered <- res_parsed %>% filter(!(N == 0 & NL == 20))
  
  # Bind expanded baseline back
  res_final <- bind_rows(res_filtered, base0_expanded) %>% 
    mutate(sdSR = case_when(
      N == 0 & NL != 20 ~ sdSR,
      TRUE ~ sdSR
    ))
} else {
  # If no N=0 baseline exists, use the original data
  res_final <- res_parsed
}

# Create the baseline point for each C value (if they exist)
baseline_unique <- res_final %>% 
  filter(N == 0) %>%
  group_by(C) %>%
  slice(1) %>%
  ungroup()

# Create complete dataset for points (N > 0)
complete_data <- res_final %>% filter(N > 0)

```
```{r}
cb_colors <- c(
  "#029E73",  # Green
  "#0173B2",  # Blue
  "#DE8F05",  # Orange
  "#CC78BC",  # Purple
  "firebrick"   # Brown
)
```

```{r}
#| fig-width: 10
#| fig-height: 5

# After your res_final creation and before creating the plot, add:

# Extract the neutral scenario data
neutral_data <- res_parsed %>% 
  filter(param == "neutral") %>%
  slice(1)  # Take first row if there are duplicates

# Create neutral data frame expanded to all C values
if(nrow(neutral_data) > 0) {
  neutMC_df <- expand.grid(
    N = 0,
    meanMC = neutral_data$meanMC,
    sdMC = neutral_data$sdMC,
    C = unique(res_final$C),
    NL = 20
  )
} else {
  neutMC_df <- data.frame()  # Empty if no neutral data
}

# Then add to your plot (after the baseline points, before facet_wrap):
plotNDD_MC <- ggplot() +
  # Plot lines connecting all points (including baseline)
  geom_line(data = res_final, 
            aes(x = N, y = meanMC, color = factor(NL), group = NL), 
            size = 0.8) +
  # Plot colored points for N > 0
  geom_point(data = complete_data, 
             aes(x = N, y = meanMC, color = factor(NL)), 
             size = 2, position = position_dodge(width = 0.075)) +
  geom_errorbar(data = complete_data,
                aes(x = N, y = meanMC, color = factor(NL),
                    ymin = meanMC - sdMC, ymax = meanMC + sdMC),
                width = 0.05, alpha = .5, size = .75,
                position = position_dodge(width = 0.075)) +

  # Add neutral scenario points
  {if(exists("neutMC_df") && nrow(neutMC_df) > 0) {
    list(
      geom_point(data = neutMC_df,
                 aes(x = N, y = meanMC),
                 color = "darkgrey", size = 4, shape = 3,
                  position = position_nudge(x = 0.02)),
      geom_errorbar(data = neutMC_df,
                    aes(x = N, ymin = meanMC - sdMC, ymax = meanMC + sdMC),
                    color = "darkgrey", width = 0.005, size = 0.75,
                     position = position_nudge(x = 0.02))
    )
  }} +
  facet_wrap(~ C, ncol = 3, scales = "fixed",
             labeller = labeller(C = function(x) paste("nDD radius =", x))) +
  labs(x = "nDD strength",
       y = "mean stabilizing CDD (%)",
       color = "nDD lambda\n(specificity)") +
  theme_classic(base_size = 14) +
  theme(
    strip.background = element_blank(),
    legend.position = "right",
    strip.text = element_text(size = 14, margin = margin(b = -0)),
    plot.margin = margin(20, 20, 20, 20),
    panel.spacing = unit(1, "lines"),
    axis.title.x = element_text(margin = margin(t = 14)),
    axis.title.y = element_text(margin = margin(r = 14)),
    panel.grid.major.y = element_line(color = "grey90", size = 0.2),
    panel.grid.minor.y = element_line(color = "grey95", size = 0.2),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank()
  ) + 
  coord_cartesian(clip = "off") +
  scale_color_manual(values = cb_colors) +
  scale_x_continuous(breaks = seq(0, 1, by = 0.2)) + 
    # Add baseline points if they exist
      geom_point(data = baseline_unique, 
                 aes(x = N, y = meanMC), 
                 color = "black", size = 4, shape = 3) +
      geom_errorbar(data = baseline_unique,
                    aes(x = N, y = meanMC, ymin = meanMC - sdMC, ymax = meanMC + sdMC),
                    color = "black", width = 0.005, alpha = 1) 

print(plotNDD_MC)

```

```{r}
# pdf(paste0(root, "local/figures/plot_sr-params/nddEffectOnMC.pdf"), width = 10, height = 5, onefile = TRUE, useDingbats = FALSE)
# print(plotNDD_MC)
# dev.off()
```

```{r}
cb_colors <- c(
  "#029E73",  # Green
  "#0173B2",  # Blue
  "#DE8F05",  # Orange
  "#CC78BC",  # Purple
  "firebrick"   # Brown
)
```

```{r}
#| fig-width: 10
#| fig-height: 5

# Parse the param column to extract N, NL, and C values
res_parsed <- res %>%
  # Split the param column at the underscore to get the two parts
  separate(param, into = c("part1", "part2"), sep = "_", remove = FALSE) %>%
  # Extract N, NL, C from first part (P1-L5-C1 format)
  extract(part1, into = c("P1", "L1", "C1"), regex = "P([0-9]+)-L([0-9]+)-C([0-9]+)", remove = FALSE) %>%
  # Extract N, NL, C from second part (N0-L20-C1 format)
  extract(part2, into = c("N", "NL", "C"), regex = "N([0-9.]+)-L([0-9.]+)-C([0-9]+)", remove = FALSE) %>%
  # Convert to numeric
  mutate(
    N = as.numeric(N),
    NL = as.numeric(NL),
    C = as.numeric(C)
  ) #%>%
  # Remove the temporary columns we don't need
  # select(-part1, -part2, -P1, -L1, -C1)

# Check the parsed data
print("Parsed data structure:")
print(head(res_parsed))

# Get the N=0 baseline (assuming it exists for NL=20)
base0 <- res_parsed %>% filter(N == 0, NL == 20)

# All NL values present in the data
all_NL <- sort(unique(res_parsed$NL))

# For each C value, replicate the N=0 point across all NL values if needed
if(nrow(base0) > 0) {
  base0_expanded <- do.call(rbind, lapply(unique(base0$C), function(c_val) {
    base_c <- base0[base0$C == c_val, ]
    expanded <- base_c[rep(1, length(all_NL)), ]
    expanded$NL <- all_NL
    return(expanded)
  }))
  
  # Remove the original N=0, NL=20 entries to avoid duplicates
  res_filtered <- res_parsed %>% filter(!(N == 0 & NL == 20))
  
  # Bind expanded baseline back
  res_final <- bind_rows(res_filtered, base0_expanded) %>% 
    mutate(sdSR = case_when(
      N == 0 & NL != 20 ~ sdSR,
      TRUE ~ sdSR
    ))
} else {
  # If no N=0 baseline exists, use the original data
  res_final <- res_parsed
}

# Create the baseline point for each C value (if they exist)
baseline_unique <- res_final %>% 
  filter(N == 0) %>%
  group_by(C) %>%
  slice(1) %>%
  ungroup()

# Create complete dataset for points (N > 0)
complete_data <- res_final %>% filter(N > 0)

# Create the plot
plotNDD_SR <- ggplot() +
  # Plot lines connecting all points (including baseline)
  geom_line(data = res_final, 
            aes(x = N, y = meanSR, color = factor(NL), group = NL), 
            size = 0.8) +
  # Plot colored points for N > 0
  geom_point(data = complete_data, 
             aes(x = N, y = meanSR, color = factor(NL)), 
             size = 2, position = position_dodge(width = 0.075)) +
  geom_errorbar(data = complete_data,
                aes(x = N, y = meanSR, color = factor(NL),
                    ymin = meanSR - sdSR, ymax = meanSR + sdSR),
                width = 0.05, alpha = .5, size = .75,
                position = position_dodge(width = 0.075)) +
  # Add baseline points if they exist
  {if(nrow(baseline_unique) > 0) {
    list(
      geom_point(data = baseline_unique, 
                 aes(x = N, y = meanSR), 
                 color = "black", size = 4, shape = 3),
      geom_errorbar(data = baseline_unique,
                    aes(x = N, y = meanSR, ymin = meanSR - sdSR, ymax = meanSR + sdSR),
                    color = "black", width = 0.005, alpha = 1)
    )
  }} +
  facet_wrap(~ C, ncol = 3, scales = "fixed",
             labeller = labeller(C = function(x) paste("nDD radius =", x))) +
  labs(x = "nDD strength",
       y = "mean species richness",
       color = "nDD lambda\n(specificity)") +
  theme_classic(base_size = 14) +
  theme(
    strip.background = element_blank(),
    legend.position = "right",
    strip.text = element_text(size = 14, margin = margin(b = -20)),
    plot.margin = margin(20, 20, 20, 20),
    panel.spacing = unit(1, "lines"),
    axis.title.x = element_text(margin = margin(t = 14)),
    axis.title.y = element_text(margin = margin(r = 14)),
    panel.grid.major.y = element_line(color = "grey90", size = 0.2),
    panel.grid.minor.y = element_line(color = "grey95", size = 0.2),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank()
  ) + 
  coord_cartesian(clip = "off") +
  scale_color_manual(values = cb_colors) +
  scale_x_continuous(breaks = seq(0, 1, by = 0.2))

neutSR_df <- data.frame(
  N = 0,                          
  meanSR = neutSR$meanSR,
  sdSR = neutSR$sdSR,
  C = unique(res_final$C)[1],     
  NL = 20                         
)

neutSR_df <- expand.grid(
  N = 0,
  meanSR = neutSR$meanSR,
  sdSR = neutSR$sdSR,
  C = unique(res_final$C),
  NL = 20
)

plotNDD_SR <- plotNDD_SR +
  geom_point(data = neutSR_df,
             aes(x = N, y = meanSR),
             color = "grey", size = 4, shape = 3) +
  geom_errorbar(data = neutSR_df,
                aes(x = N, ymin = meanSR - sdSR, ymax = meanSR + sdSR),
                color = "grey", width = 0.005, size = 0.75)

print(plotNDD_SR)

```

```{r}
# pdf(paste0(root, "local/figures/plot_sr-params/nddEffectOnSR.pdf"), width = 10, height = 5, onefile = TRUE, useDingbats = FALSE)
# print(plotNDD_SR)
# dev.off()
```
