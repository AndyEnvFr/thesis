---
title: "PhyloSim Changes"
author: "A.I."
format:
  html:
    number-sections: true
editor: visual
---

```{r}
#| warning: false
library(PhyloSim)
library(parallel)
library(dplyr)
library(tidyverse)
library(lattice)
library(ggplot2)
library(metafor)
library(MASS)
library(viridis)
# root <- "~/Uni/Master/MA/" # work from local machine
root <- "~/cyber_synch/" # work from uni bayreuth server
```

Data is portioned in 3 50-fold-batches for better handling. Therefore, the analysis is repeated three times ranRuns\_\[i,ii,iii\].rds

## Data preparation

```{r}
#| eval: false

runsRaw  <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranRunsFixDC_iii.rds"))
```

```{r}
#| eval: false

# get conspecific neighbors and proper naming
runsRaw  <- getConNeigh(runsRaw, radius = 5)
```

```{r}
# make the runs more slim
runsRaw <- lapply(runsRaw, function(x){
  x$Output <- x$Output[101:200]
  x$Model$runs <- x$Model$runs[101:200]
  return(x)
})
```

```{r}
namesShort <- names(runsRaw) %>%
  stringr::str_remove("_disp.+") %>% 
  stringr::str_replace("Cut", "-C") %>% 
  stringr::str_replace("Cut", "-C") %>% 
  stringr::str_replace("pdd", "P") %>% 
  stringr::str_replace("ndd", "N") %>% 
  stringr::str_replace_all("Var", "-L") %>% 
  stringr::str_replace_all("\\d+\\.\\d{5,}", function(x) substr(x, 1, 6))
```

```{r}
names(runsRaw) <- namesShort
class(runsRaw) <- "PhylosimList"
```

```{r}
S <- getSpecTime(runsRaw, plot = TRUE)
```

Next, we convert the matrix data into tabular data. With the argument detailedParams we include the parameter settings a seperate cols. We save the tabular data.

```{r}
#| eval: false

# convert matrices to tabular data. This is done parallel, as it takes longer
cl <- makeCluster(50)
clusterExport(cl, c("getMatToTab", "runsRaw"))
tab <- parLapply(cl = cl, X = runsRaw, fun = function(x) getMatToTab(x, detailedParams = TRUE))
stopCluster(cl)


# saveRDS(tab, paste0(root, "/local/runs/mstr/20250903/ranTabFixDC_iii.rds"))
```

```{r}
tab <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranTabFixDC_ii.rds"))
```

```{r}
# keep only first timespot in census

cores <- length(tab)
cl <- makeCluster(50)

clusterEvalQ(cl, {
  library(dplyr)
})

tabS <- parLapply(cl, tab, function(x) {
  x %>%
    filter(abund > 100) %>%
    mutate(specIdCen = paste0(specId, census)) %>%
    select(-indId)
})

stopCluster(cl)
```

### Metafor analysis: correcting for uncertainty

```{r}
#| eval: false

cl <- makeCluster(50)

mcS_err <- parLapply(cl, tabS, function(x) {
  specIDs <- unique(x$specIdCen)
  res <- vector("list", length(specIDs))
  
  i <- 1
  for (sID in specIDs) {
    dat <- x[x$specIdCen == sID, ]
    mod <- glm(mortNextGen ~ con, data = dat, family = binomial())
    sfm <- summary(mod)$coefficients
    vc <- vcov(mod)[c("(Intercept)", "con"), c("(Intercept)", "con")]

    mort0 <- plogis(coef(mod)[1])
    mort1 <- plogis(coef(mod)[1] + coef(mod)[2])
    
    res[[i]] <- list(
      specId = sID,
      abund = dat$abund[1],
      mort_change = mort1 - mort0,
      coef = coef(mod)[c(1,2)],
      vcov = vc
    )
    i <- i + 1
  }
  return(res)
})

# Stop the cluster
stopCluster(cl)
```

## compute variance of the marginal effect through a "posterior" simulation

```{r}
#| eval: false

cl <- makeCluster(50)
mcS_err_sim <- parLapply(cl, mcS_err, function(x){
  lapply(x, function(y){
    sim <- MASS::mvrnorm(n = 100, mu = c(y$coef[1], y$coef[2]), Sigma = y$vcov)
    mort0 <- plogis(sim[, 1])
    mort1 <- plogis(sim[, 1] + sim[, 2])
    mort_diff <- mort1 - mort0
    
    return(data.frame(
      abund = y$abund,
      specId = y$specId,
      mean = mean(mort_diff),
      se = sd(mort_diff),
      ci_low = quantile(mort_diff, 0.025),
      ci_high = quantile(mort_diff, 0.975)
    ))
  })
})
# Stop the cluster
stopCluster(cl)
```

## unlist inner lists and add log abund

```{r}
#| eval: false

m4 <- lapply(mcS_err_sim, function(group) {
  do.call(rbind, group)
})

m4 <- lapply(m4, function(group) {
  row.names(group) <- NULL
  group <- group %>% 
    mutate(log_N = log(abund))
  return(group)
})
```

## fitting model

```{r}
#| eval: false

dat_meta <- lapply(m4, function(x) {
  escalc(measure = "GEN", yi = mean, sei = se, slab = specId, data = x)
})
```

```{r}
#| eval: false

# # Detect available cores and create a cluster
# cl <- makeCluster(length(dat_meta))
# 
# # Export needed objects and packages to the workers
# clusterExport(cl, varlist = c("dat_meta"), envir = environment())
# 
# # Run in parallel
# metamod <- parLapply(cl, dat_meta, function(x) {
#   metafor::rma(
#     yi = yi,
#     vi = vi,
#     mods = ~ log_N,
#     method = "REML",
#     data = x
#   )
# })
# 
# # Stop cluster
# stopCluster(cl)
# 
# names(metamod) <- namesShort
```

```{r}
cl <- makeCluster(length(dat_meta))
clusterExport(cl, varlist = c("dat_meta"), envir = environment())

metamod <- parLapply(cl, dat_meta, function(x) {
  tryCatch({
    metafor::rma(
      yi = yi,
      vi = vi,
      mods = ~ log_N,
      method = "REML",
      data = x
    )
  }, error = function(e) {
    return(NULL)  # Return NULL for failed models
  })
})

stopCluster(cl)

# Remove NULL elements and keep names aligned
failed_indices <- sapply(metamod, is.null)
namesShort <- names(metamod)
metamod <- metamod[!failed_indices]
names(metamod) <- namesShort[!failed_indices]

# Report which models failed
if(any(failed_indices)) {
  cat("Failed models:", paste(namesShort[failed_indices], collapse = ", "), "\n")
}
```

```{r}
# deleting one scenario

# saveRDS(dat_meta, paste0(root, "/local/runs/mstr/20250903/ranFixDCDatmetaMax_ii.rds"))
# saveRDS(metamod, paste0(root, "/local/runs/mstr/20250903/ranFixDCMetamodMax_ii.rds"))


metamod <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranFixDCMetamodMax_i.rds"))
datmeta <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranFixDCDatmetaMax_i.rds"))
runsCon <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranRunsFixDC_i.rds"))
```

## predictions

### log_N
```{r}
namesShort <- names(metamod) %>% 
  str_replace("pdd", "P") %>% 
  str_replace("Var", "-L") %>% 
  str_replace("Cut", "-C") %>% 
  str_replace("ndd", "N") %>% 
  str_replace("Var", "-L") %>% 
  str_replace("Cut", "-C") %>% 
  str_remove("_disp1_sr2_fbmr3000_faoM") %>% 
  str_replace_all("([0-9]+\\.[0-9]+)", function(x) sprintf("%.4f", as.numeric(x))
  )

names(metamod) <- namesShort
names(datmeta) <- namesShort
names(runsCon) <- namesShort
```



```{r}
## --- build predictions (as you had) ---
pred <- lapply(datmeta, function(x){
  expand_grid(log_N = seq(min(x$log_N, na.rm = TRUE),
                          max(x$log_N, na.rm = TRUE),
                          length.out = 1000))
})
pred <- lapply(pred, function(x){
  x$abund <- exp(x$log_N)
  x
})
pred <- lapply(seq_along(pred), function(i){
  x <- pred[[i]]
  y <- metamod[[i]]
  cbind(x, predict(object = y, newmods = x$log_N))
})
names(pred) <- namesShort  # <- your vector like the one you listed

srRaw <- getSpecTime(runsCon, plot = FALSE)

# Get slopes
slope <- map_dbl(metamod, ~ coef(.x)[2]) %>%
  enframe(name = "param", value = "slope")

# Get standard error of slopes
seSlope <- map_dbl(metamod, ~ se(.x)[2]) %>%
  enframe(name = "param", value = "seSlope")

# Get abundance (use max to exclude extreme values)
abund <- map_dbl(datmeta, ~ max(.x$abund)) %>%
  enframe(name = "param", value = "abund")

# Get CV of predictions
cv <- map(pred, ~ {
  meanMC <- mean(.x$pred)
  sdMC <- sd(.x$pred)
  rangeMC <- diff(range(.x$pred))
  tibble(meanMC = meanMC, sdMC = sdMC, rangeMC = rangeMC, cvMC = sdMC / meanMC)
}) %>%
  bind_rows(.id = "param")

# Get species richness summary
sr <- map(srRaw, ~ {
  vals <- .x$spec_rich[99:200]
  tibble(
    meanSR = mean(vals),
    sdSR = sd(vals),
    medianSR = median(vals)
  )
}) %>%
  bind_rows(.id = "param") %>%
  mutate(medianSR = as.integer(medianSR))

# Combine all results
res <- list(slope, seSlope, sr, abund, cv) %>%
  reduce(left_join, by = "param") %>%
  mutate(abund = as.integer(abund))

# Filter by scenario types
scenario_comps <- paste0("C", 1:5)

res_scenarios <- map(scenario_comps, ~ {
  pattern <- paste0(".*-", .x)  # matches both P and N runs
  res %>% filter(grepl(pattern, param))
}) %>%
  set_names(scenario_comps)
```


```{r}
#| fig-width: 7
#| fig-height: 7
#| fig-cap: ["Relationships between stabilizing CDD parameters and community diversity metrics for randomly sampled nDD and pDD scenarios. A linear regression with 95% confidence intervals is fitted for the data in the corresponding panels and corresponding P values provided. Data is sorted by nDD spatial kernel (= nDC) and pdd(= pDC), except the last plot that contains all combined data. The slope (x-axis top-left and -right) results from the metaregression (see above) between stabilizing CDD and species abundance - the more negative it is, the stronger the negative relationship. Mean species richness is averaged across one run after filtering out non-equilibrium generations. Max abundance is the maximum abundance of any species within one run. CV is the coefficient of variation calculated by standard deviation of stabilizing CDD divided by mean stabilizing CDD. Top-left: Mean species richness vs slope. Top-right: Maximum abundance vs slope with log-transformed model fit. Bottom-left: Mean species richness vs CV stabilizing CDD (%) colored by slope values. Bottom-right: Mean species richness vs mean stabilizing CDD (%) with log-transformed relationship and slope-colored points.","","","","","","","","","",""]

## ---- helper functions ----
pred_lm_log <- function(mod, newdata, k = 2) {
  pred <- predict(mod, newdata = newdata, se.fit = TRUE)
  fit <- exp(pred$fit)
  lo  <- exp(pred$fit - k*pred$se.fit)
  hi  <- exp(pred$fit + k*pred$se.fit)
  list(fit = fit, lo = lo, hi = hi)
}

# Helper function to format p-values
format_pvalue <- function(p) {
  if (p < 0.001) {
    return("p < 0.001")
  } else if (p < 0.01) {
    return(sprintf("p = %.3f", p))
  } else {
    return(sprintf("p = %.2f", p))
  }
}

# Unified function for species richness vs slope plot (WITH HORIZONTAL ERROR BARS)
plot_sr_slope <- function(dat, tag, ylim_sr = c(40,100)) {
  fm1 <- lm(meanSR ~ slope, data = dat)
  newdat <- data.frame(slope = seq(min(dat$slope), max(dat$slope), length = 100))
  predi <- predict(fm1, newdata = newdat, se.fit = TRUE)
  
  # Extract p-value
  p_val <- summary(fm1)$coefficients[2, 4]  # p-value for slope coefficient
  p_text <- format_pvalue(p_val)
  
  plot(dat$slope, dat$meanSR, ylim = ylim_sr, pch = 16, col = "blue", cex = .8,
       xlab = "slope of fitted meta regression", ylab = "mean species richness")
  points(dat$slope, dat$medianSR, pch = 16, cex = .8, col = "red")
  
  # Horizontal error bars for seSlope
  arrows(dat$slope - dat$seSlope, dat$meanSR, dat$slope + dat$seSlope, dat$meanSR,
         angle = 90, code = 3, length = 0.05, lwd = .5, col = rgb(0,0,0,.5))
  # # Vertical error bars (existing)
  # arrows(dat$slope, dat$meanSR - dat$sdSR, dat$slope, dat$meanSR + dat$sdSR,
  #        angle = 90, code = 3, length = 0.05)
  
  lines(newdat$slope, predi$fit, lwd = 2, col = 1)
  lines(newdat$slope, predi$fit - 2*predi$se.fit, lwd = 1, lty = 2, col = 1)
  lines(newdat$slope, predi$fit + 2*predi$se.fit, lwd = 1, lty = 2, col = 1)
  legend("topright", legend = c("mean SR", "median SR"),
         pch = c(16,16), col = c(4,2), bty = "n")
  
  # Add p-value text
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Unified function for abundance vs slope plot (WITH HORIZONTAL ERROR BARS)
plot_abund_slope <- function(dat, tag) {
  # Log-transform abundance (add 1 to avoid log(0))
  dat$log_abund <- log(dat$abund)
  # Fit linear model on log(abundance)
  fm <- lm(log_abund ~ slope, data = dat)
  # Prediction along slope range
  newdat <- data.frame(slope = seq(min(dat$slope), max(dat$slope), length = 100))
  pg <- pred_lm_log(fm, newdat, k = 2)
  # Extract p-value for slope
  p_val <- summary(fm)$coefficients[2, 4]
  p_text <- format_pvalue(p_val)
  # Plot log-transformed abundances
  plot(dat$slope, dat$log_abund, pch = 16, col = 1, cex = .8,
       xlab = "slope of fitted meta regression", ylab = "log(max abundance)")
  
  # Horizontal error bars for seSlope (NEW)
  arrows(dat$slope - dat$seSlope, dat$log_abund, dat$slope + dat$seSlope, dat$log_abund,
         angle = 90, code = 3, length = 0.05,lwd = .5, col = rgb(0,0,0,.5))
  
  # Add fitted line and confidence intervals
  lines(newdat$slope, log(pg$fit), lwd = 2, col = 1)
  lines(newdat$slope, log(pg$lo), lwd = 1, lty = 2, col = 1)
  lines(newdat$slope, log(pg$hi), lwd = 1, lty = 2, col = 1)
  # Add legend
  # Add p-value text
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Unified function for species richness vs CV mortality change (unchanged)
plot_sr_cvmc <- function(dat, tag, ylim_sr = c(40,90)) {
  fm3 <- lm(meanSR ~ cvMC, data = dat)
  newdat <- data.frame(cvMC = seq(min(dat$cvMC), max(dat$cvMC), length = 100))
  pred <- predict(fm3, newdata = newdat, se.fit = TRUE)
  
  # Extract p-value
  p_val <- summary(fm3)$coefficients[2, 4]  # p-value for cvMC coefficient
  p_text <- format_pvalue(p_val)
  
  cols <- viridis(length(dat$slope))[rank(dat$slope)]
  cols_error <- cols %>% adjustcolor(alpha.f = 0.75)
  plot(dat$cvMC, dat$meanSR, ylim = ylim_sr, pch = 16, col = cols, cex = .8,
       xlab = "CV of stabilizing CDD", ylab = "mean species richness")
  arrows(dat$cvMC, dat$meanSR - dat$sdSR, dat$cvMC, dat$meanSR + dat$sdSR,
         angle = 90, code = 3, length = 0.05, col = cols_error, lwd =.5)
  lines(newdat$cvMC, pred$fit, lwd = 2, col = 1)
  lines(newdat$cvMC, pred$fit - 2*pred$se.fit, lwd = 1, lty = 2, col = 1)
  lines(newdat$cvMC, pred$fit + 2*pred$se.fit, lwd = 1, lty = 2, col = 1)
  legend("topright", title = "slope",
         fill = viridis(5),
         legend = signif(seq(min(dat$slope), max(dat$slope), length.out = 5), 2),
         bty = "n", cex = .8)
  
  # Add p-value text
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Unified function for species richness vs mean stabilizing CDD (unchanged)
plot_sr_meanmc <- function(dat, tag, ylim_sr = c(40,90)) {
  fm4 <- lm(meanSR ~ meanMC, data = dat)
  newdat <- data.frame(meanMC = seq(min(dat$meanMC), max(dat$meanMC), length = 100))
  pred <- predict(fm4, newdata = newdat, se.fit = TRUE)
  
  # Extract p-value
  p_val <- summary(fm4)$coefficients[2, 4]  # p-value for log(meanMC) coefficient
  p_text <- format_pvalue(p_val)
  
  cols <- viridis(length(dat$slope))[rank(dat$slope)]
  cols_error <- cols %>% adjustcolor(alpha.f = .75)
  plot(dat$meanMC, dat$meanSR, ylim = ylim_sr, pch = 16, col = cols, cex = .8,
       xlab = "mean stabilizing CDD (%)", ylab = "mean species richness")
    # Horizontal error bars for sdMC
  arrows(dat$meanMC - dat$sdMC, dat$meanSR, dat$meanMC + dat$sdMC, dat$meanSR,
         angle = 90, code = 3, length = 0.05, lwd = .5, col = cols_error)
  lines(newdat$meanMC, pred$fit, lwd = 2, col = 1)
  lines(newdat$meanMC, pred$fit - 2*pred$se.fit, lwd = 1, lty = 2, col = 1)
  lines(newdat$meanMC, pred$fit + 2*pred$se.fit, lwd = 1, lty = 2, col = 1)
  legend("bottomright", title = "slope",
         fill = viridis(5),
         legend = signif(seq(min(dat$slope), max(dat$slope), length.out = 5), 2),
         bty = "n", cex = .8)
  
  # Add p-value text
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]),  
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Master plotting function for all scenario plots (4 plot types per scenario)
plot_all_scenarios <- function(scenario_list, scenario_names, 
                              ylim_sr = c(40,100)) {
  n_scenarios <- length(scenario_list)
  
  # For each scenario, create all 4 plot types
  for(i in 1:n_scenarios) {
    # Set up 2x2 grid for each scenario with main title
    # par(mfrow = c(2, 2), mar = c(4,4,3,2), oma = c(0, 0, 2, 0))       # change this for single or mulit-panel plots
    par(mfrow = c(1, 1), mar = c(6,4,3,2), oma = c(0, 0, 2, 0))       # change this for single or mulit-panel plots
    
    # Main analysis plots
    plot_sr_slope(scenario_list[[i]], scenario_names[i], ylim_sr)
    plot_abund_slope(scenario_list[[i]], scenario_names[i])
    plot_sr_cvmc(scenario_list[[i]], scenario_names[i], ylim_sr)
    plot_sr_meanmc(scenario_list[[i]], scenario_names[i], ylim_sr)
    
    # Add main title for the entire 4-panel plot
    mtext(scenario_names[i], outer = TRUE, cex = 1.5, font = 2)
  }
}

## ---- apply to scenarios C1-C5 ----
# Assuming you have data objects: resC1, resC2, resC3, resC4, resC5
scenario_data1<- res_scenarios[str_detect(string = names(res_scenarios),pattern = "1")]
scenario_label1 <- "DC = 1"
scenario_data2<- res_scenarios[str_detect(string = names(res_scenarios),pattern = "2")]
scenario_label2 <- "DC = 2"
scenario_data3<- res_scenarios[str_detect(string = names(res_scenarios),pattern = "3")]
scenario_label3 <- "DC = 3"
scenario_data4<- res_scenarios[str_detect(string = names(res_scenarios),pattern = "4")]
scenario_label4 <- "DC = 4"
scenario_data5<- res_scenarios[str_detect(string = names(res_scenarios),pattern = "5")]
scenario_label5 <- "DC = 5"

# Generate all plots for negative scenarios
plot_all_scenarios(scenario_data1, scenario_label1,
                   ylim_sr = c(40,100))
plot_all_scenarios(scenario_data2, scenario_label2,
                   ylim_sr = c(40,100))
plot_all_scenarios(scenario_data3, scenario_label3,
                   ylim_sr = c(40,100))
plot_all_scenarios(scenario_data4, scenario_label4,
                   ylim_sr = c(40,100))
plot_all_scenarios(scenario_data5, scenario_label5,
                   ylim_sr = c(40,100))

# Generate plot for combined data
plot_all_scenarios(list(res), "combined data", 
                   ylim_sr = c(40,100))
```


```{r}
# saveRDS(res, paste0(root, "/local/runs/mstr/20250903/ranResFixDC_i.rds"))
```

```{r}
#| fig-width: 7
#| fig-height: 7
#| fig-cap: "Relationships between stabilizing CDD parameters and community diversity metrics for randomly sampled nDD and pDD scenarios. A linear regression with 95% confidence intervals is fitted for the data in the corresponding panels. Data comes from 150 runs with randomly sampled parametrization. The slope results from the metaregression and encapsulates the relationship between stabilizing CDD and species abundance - the more negative it is, the stronger the negative relationship. Mean species richness is averaged across one run after filtering out non-equilibrium generations. Max abundance is the maximum abundance of any species within one run. CV is the coefficient of variation calculated by standard deviation of stabilizing CDD divided by mean stabilizing CDD. Top-left: Mean species richness vs slope. Top-right: Maximum abundance vs slope with log-transformed model fit. Bottom-left: Mean species richness vs CV stabilizing CDD (%) colored by slope values. Bottom-right: Mean species richness vs mean stabilizing CDD (%) with log-transformed relationship and slope-colored points."

resi <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResFixDC_i.rds"))
resii <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResFixDC_ii.rds"))
resiii <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResFixDC_iii.rds"))

res_all <- rbind(resi,resii,resiii)

# Generate plot for combined data
plot_all_scenarios(list(res_all), "", 
                   ylim_sr = c(40,100))
# 
# pdf(paste0(root, "local/figures/ran/ran_allFixDC.pdf"), width = 5, height = 5, onefile = TRUE, useDingbats = FALSE)
# plot_all_scenarios(list(res_all), "",
#                    ylim_sr = c(40,100))
# dev.off()
```


## rac

```{r}
rac(runs = runs$ndd1var5cut1_pdd1var20cut5, which.result = seq(180,200,2), xmax = 90, ymax = 30000)
rac(runs = runs$ndd1var5cut1_pdd1var20cut3, which.result = seq(180,200,2), xmax = 90, ymax = 30000)
rac(runs = runs$ndd1var5cut1_pdd0.6var0.1cut1, which.result = seq(180,200,2), xmax = 90, ymax = 30000)
rac(runs = runs$ndd1var5cut1_pdd0.4var0.1cut3, which.result = seq(180,200,2), xmax = 90, ymax = 30000)
```

## mutlidemsional plots

```{r}
# Load required libraries
library(ggplot2)
library(dplyr)
library(stringr)
library(gridExtra)

# Assuming your data is in a dataframe called 'res'
# If not, load it first with: res <- read.csv("your_file.csv") or similar

# 1. Plot with meanSR vs slope, colored by int
plot1 <- ggplot(res, aes(x = slope, y = meanSR, color = int)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "Intercept") +
  labs(title = "Mean SR vs Slope (colored by intercept)",
       x = "Slope",
       y = "Mean SR") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 2. Plot with meanSR vs slope, colored by cvMC
plot2 <- ggplot(res, aes(x = slope, y = meanSR, color = cvMC)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "CV") +
  labs(title = "Mean SR vs Slope (colored by CV)",
       x = "Slope",
       y = "Mean SR") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# Extract parameters from the param column
# Parse the parameter string to extract P, L, C, N values
parse_params <- function(param_string) {
  # Extract P value and its L,C
  p_part <- str_extract(param_string, "P[0-9.]+\\-L[0-9.]+\\-C[0-9]+")
  n_part <- str_extract(param_string, "N[0-9.]+\\-L[0-9.]+\\-C[0-9]+")
  
  # Extract individual values
  P <- as.numeric(str_extract(str_extract(p_part, "P[0-9.]+"), "[0-9.]+"))
  PL <- as.numeric(str_extract(str_extract(p_part, "L[0-9.]+"), "[0-9.]+"))
  PC <- as.numeric(str_extract(str_extract(p_part, "C[0-9]+"), "[0-9]+"))
  
  N <- as.numeric(str_extract(str_extract(n_part, "N[0-9.]+"), "[0-9.]+"))
  NL <- as.numeric(str_extract(str_extract(n_part, "L[0-9.]+"), "[0-9.]+"))
  NC <- as.numeric(str_extract(str_extract(n_part, "C[0-9]+"), "[0-9]+"))
  
  return(data.frame(P = P, PL = PL, PC = PC, N = N, NL = NL, NC = NC))
}

# Apply the parsing function
parsed_params <- do.call(rbind, lapply(res$param, parse_params))
res_extended <- cbind(res, parsed_params)

# 3. Plot P vs N, colored by meanSR
plot3 <- ggplot(res_extended, aes(x = P, y = N, color = meanSR)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "Mean SR") +
  labs(title = "P vs N (colored by Mean SR)",
       x = "P parameter",
       y = "N parameter") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 4. Plot PL vs NL, colored by meanSR
plot4 <- ggplot(res_extended, aes(x = PL, y = NL, color = meanSR)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "Mean SR") +
  labs(title = "PL vs NL (colored by Mean SR)",
       x = "PL parameter",
       y = "NL parameter") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 5. Plot PC vs NC, colored by meanSR
plot5 <- ggplot(res_extended, aes(x = PC, y = NC, color = meanSR)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "Mean SR") +
  labs(title = "PC vs NC (colored by Mean SR)",
       x = "PC parameter",
       y = "NC parameter") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# Display plots
print(plot1)
print(plot2)
print(plot3)
print(plot4)
print(plot5)

# If you want to save all plots in one figure
combined_plot <- grid.arrange(
  plot3, plot4, plot5,
  ncol = 2, nrow = 2,
  top = "Parameter Relationships"
)

# Save plots if needed
# ggsave(paste0(root, "local/figures/ran/meanSR_slope_int_iii.pdf"), plot1, width = 10, height = 6, dpi = 300)
# ggsave(paste0(root, "local/figures/ran/meanSR_slope_CV_iii.pdf"), plot2, width = 10, height = 6, dpi = 300)
# ggsave(paste0(root, "local/figures/ran/meanSR_params_iii.pdf"), combined_plot, width = 15, height = 10, dpi = 300)
```

#all results combined

```{r}
resi <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResMax_i.rds"))
resii <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResMax_ii.rds"))
resiii <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResMax_iii.rds"))

res_all <- rbind(resi,resii,resiii)
```

```{r}
# filter by scenarios
resPC1 <- res_all %>%
  dplyr::filter(grepl("P.*-C1_", param))
resPC2 <- res_all %>%
  dplyr::filter(grepl("P.*-C2_", param))
resPC3 <- res_all %>%
  dplyr::filter(grepl("P.*-C3_", param))
resPC4 <- res_all %>%
  dplyr::filter(grepl("P.*-C4_", param))
resPC5 <- res_all %>%
  dplyr::filter(grepl("P.*-C5_", param))
# filter by scenarios
resNC1 <- res_all %>%
  dplyr::filter(grepl("N.*-C1$", param))
resNC2 <- res_all %>%
  dplyr::filter(grepl("N.*-C2$", param))
resNC3 <- res_all %>%
  dplyr::filter(grepl("N.*-C3$", param))
resNC4 <- res_all %>%
  dplyr::filter(grepl("N.*-C4$", param))
resNC5 <- res_all %>%
  dplyr::filter(grepl("N.*-C5$", param))
```

```{r}
#| fig-width: 10
#| fig-height: 6.5

## ---- helper functions ----
pred_glm_pois <- function(mod, newdata, k = 2) {
  lp <- predict(mod, newdata = newdata, se.fit = TRUE, type = "link")
  fit <- exp(lp$fit)
  lo  <- exp(lp$fit - k*lp$se.fit)
  hi  <- exp(lp$fit + k*lp$se.fit)
  list(fit = fit, lo = lo, hi = hi)
}

# Helper function to format p-values
format_pvalue <- function(p) {
  if (p < 0.001) {
    return("p < 0.001")
  } else if (p < 0.01) {
    return(sprintf("p = %.3f", p))
  } else {
    return(sprintf("p = %.2f", p))
  }
}

# Unified function for species richness vs slope plot
plot_sr_slope <- function(dat, tag, ylim_sr = c(40,100)) {
  fm1 <- lm(meanSR ~ slope, data = dat)
  newdat <- data.frame(slope = seq(min(dat$slope), max(dat$slope), length = 100))
  predi <- predict(fm1, newdata = newdat, se.fit = TRUE)
  
  # Extract p-value
  p_val <- summary(fm1)$coefficients[2, 4]  # p-value for slope coefficient
  p_text <- format_pvalue(p_val)
  
  plot(dat$slope, dat$meanSR, ylim = ylim_sr, pch = 16, col = "blue",
       xlab = "mortality change ~ abundance: slope", ylab = "mean species richness",
       main = paste0("Species Richness - Scenario ", tag))
  points(dat$slope, dat$medianSR, pch = 16, col = "red")
  arrows(dat$slope, dat$meanSR - dat$sdSR, dat$slope, dat$meanSR + dat$sdSR,
         angle = 90, code = 3, length = 0.05)
  lines(newdat$slope, predi$fit, lwd = 2, col = 1)
  lines(newdat$slope, predi$fit - 2*predi$se.fit, lwd = 1, lty = 2, col = 1)
  lines(newdat$slope, predi$fit + 2*predi$se.fit, lwd = 1, lty = 2, col = 1)
  legend("topright", legend = c("mean SR", "median SR", "fitted lm", "CI"),
         pch = c(16,16,NA,NA), lty = c(NA,NA,1,2), col = c(4,2,1,1), bty = "n")
  
  # Add p-value text
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Unified function for abundance vs slope plot
plot_abund_slope <- function(dat, tag, ylim_abund = NULL) {
  fm2 <- glm(abund ~ slope, data = dat, family = poisson())
  newdat <- data.frame(slope = seq(min(dat$slope), max(dat$slope), length = 100))
  pg <- pred_glm_pois(fm2, newdat, k = 2)
  
  # Extract p-value
  p_val <- summary(fm2)$coefficients[2, 4]  # p-value for slope coefficient
  p_text <- format_pvalue(p_val)
  
  plot(dat$slope, dat$abund, pch = 16, col = 1,
       xlab = "mortality change ~ abundance: slope", ylab = "max abundance",
       main = paste0("Abundance - Scenario ", tag), ylim = ylim_abund)
  lines(newdat$slope, pg$fit, lwd = 2, col = 1)
  lines(newdat$slope, pg$lo, lwd = 1, lty = 2, col = 1)
  lines(newdat$slope, pg$hi, lwd = 1, lty = 2, col = "grey")
  legend("topleft", legend = c("abund", "fitted glm pois", "CI"),
         pch = c(16,NA,NA), lty = c(NA,1,2), col = c(1,1,1), bty = "n")
  
  # Add p-value text
  text(x = par("usr")[1] + 0.75 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Unified function for species richness vs CV mortality change
plot_sr_cvmc <- function(dat, tag, ylim_sr = c(40,90)) {
  fm3 <- lm(meanSR ~ cvMC, data = dat)
  newdat <- data.frame(cvMC = seq(min(dat$cvMC), max(dat$cvMC), length = 100))
  pred <- predict(fm3, newdata = newdat, se.fit = TRUE)
  
  # Extract p-value
  p_val <- summary(fm3)$coefficients[2, 4]  # p-value for cvMC coefficient
  p_text <- format_pvalue(p_val)
  
  cols <- viridis(length(dat$slope))[rank(dat$slope)]
  plot(dat$cvMC, dat$meanSR, ylim = ylim_sr, pch = 16, col = cols,
       xlab = "CV Mortality Change", ylab = "mean species richness",
       main = paste0("SR vs CV MC - Scenario ", tag))
  arrows(dat$cvMC, dat$meanSR - dat$sdSR, dat$cvMC, dat$meanSR + dat$sdSR,
         angle = 90, code = 3, length = 0.05, col = cols)
  lines(newdat$cvMC, pred$fit, lwd = 2, col = 1)
  lines(newdat$cvMC, pred$fit - 2*pred$se.fit, lwd = 1, lty = 2, col = 1)
  lines(newdat$cvMC, pred$fit + 2*pred$se.fit, lwd = 1, lty = 2, col = 1)
  legend("topright", title = "slope",
         fill = viridis(5),
         legend = signif(seq(min(dat$slope), max(dat$slope), length.out = 5), 2),
         bty = "n")
  
  # Add p-value text
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Unified function for species richness vs mean mortality change
plot_sr_meanmc <- function(dat, tag, ylim_sr = c(40,90)) {
  fm4 <- lm(meanSR ~ log(meanMC), data = dat)
  newdat <- data.frame(meanMC = seq(min(dat$meanMC), max(dat$meanMC), length = 100))
  pred <- predict(fm4, newdata = newdat, se.fit = TRUE)
  
  # Extract p-value
  p_val <- summary(fm4)$coefficients[2, 4]  # p-value for log(meanMC) coefficient
  p_text <- format_pvalue(p_val)
  
  cols <- viridis(length(dat$slope))[rank(dat$slope)]
  plot(dat$meanMC, dat$meanSR, ylim = ylim_sr, pch = 16, col = cols,
       xlab = "mean Mortality Change", ylab = "mean species richness",
       main = paste0("SR vs Mean MC - Scenario ", tag))
  lines(newdat$meanMC, pred$fit, lwd = 2, col = 1)
  lines(newdat$meanMC, pred$fit - 2*pred$se.fit, lwd = 1, lty = 2, col = 1)
  lines(newdat$meanMC, pred$fit + 2*pred$se.fit, lwd = 1, lty = 2, col = 1)
  legend("bottomright", title = "slope",
         fill = viridis(5),
         legend = signif(seq(min(dat$slope), max(dat$slope), length.out = 5), 2),
         bty = "n")
  legend("topleft", legend = c("fitted lm log(meanMC)", "CI"),
         lty = c(1,2), bty = "n")
  
  # Add p-value text
  text(x = par("usr")[1] + 0.75 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}


# Master plotting function for all scenario plots (6 plot types per scenario)
plot_all_scenarios <- function(scenario_list, scenario_names, 
                              ylim_sr = c(40,100), ylim_abund = c(0,15000)) {
  n_scenarios <- length(scenario_list)
  
  # For each scenario, create all 6 plot types
  for(i in 1:n_scenarios) {
    # Set up 2x3 grid for each scenario
    par(mfrow = c(2, 3), mar = c(4,4,3,2))
    
    cat("Plotting scenario", scenario_names[i], "\n")
    
    # Main analysis plots
    plot_sr_slope(scenario_list[[i]], scenario_names[i], ylim_sr)
    plot_abund_slope(scenario_list[[i]], scenario_names[i], ylim_abund)
    plot_sr_cvmc(scenario_list[[i]], scenario_names[i], ylim_sr)
    plot_sr_meanmc(scenario_list[[i]], scenario_names[i], ylim_sr)
    
    # Additional diagnostic plots with models and p-values
    cols <- viridis(length(scenario_list[[i]]$slope))[rank(scenario_list[[i]]$slope)]
    
    # Diagnostic 1: SD MC vs slope (with linear model and p-value)
    fm_diag1 <- lm(slope ~ sdMC, data = scenario_list[[i]])
    p_val1 <- summary(fm_diag1)$coefficients[2, 4]
    p_text1 <- format_pvalue(p_val1)
    
    plot(scenario_list[[i]]$sdMC, scenario_list[[i]]$slope, pch = 16, 
         xlab = "SD Mortality Change", ylab = "slope",
         main = paste0("SD MC vs Slope - Scenario ", scenario_names[i]))
    abline(fm_diag1, col = "black", lwd = 2)
    text(x = par("usr")[1] + 0.75 * diff(par("usr")[1:2]), 
         y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
         labels = p_text1, pos = 4, cex = 0.9, col = "darkred")
    
    # Diagnostic 2: SD MC vs meanSR (colored by slope, with linear model and p-value)
    fm_diag2 <- lm(meanSR ~ sdMC, data = scenario_list[[i]])
    p_val2 <- summary(fm_diag2)$coefficients[2, 4]
    p_text2 <- format_pvalue(p_val2)
    
    plot(scenario_list[[i]]$sdMC, scenario_list[[i]]$meanSR, pch = 16, col = cols,
         xlab = "SD Mortality Change", ylab = "mean species richness",
         main = paste0("SD MC vs SR - Scenario ", scenario_names[i]), ylim = c(45,85))
    abline(fm_diag2, col = "black", lwd = 2)
    legend("bottomright", title = "slope", fill = viridis(5),
           legend = signif(seq(min(scenario_list[[i]]$slope), max(scenario_list[[i]]$slope), length.out = 5), 2), bty = "n")
    text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]), 
         y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
         labels = p_text2, pos = 4, cex = 0.9, col = "darkred")
  }
}

## ---- apply to scenarios C1-C5 ----
# Assuming you have data objects: resC1, resC2, resC3, resC4, resC5
scenario_dataP <- list(resPC1, resPC2, resPC3, resPC4, resPC5)
scenario_labelsP <- c("pC1","pC2", "pC3","pC4", "pC5")
scenario_dataN <- list(resNC1,resNC2, resNC3,resNC4, resNC5)
scenario_labelsN <- c("nC1","nC2", "nC3","nC4", "nC5")
scenario_labelsP <- c("pC1","pC2", "pC3","pC4", "pC5")

scenario_all <- list(res_all)
scenario_label_all <- c("all")


pdf(paste0(root, "local/figures/ran/ran_allMax.pdf"), width = 10, height = 6.5, onefile = TRUE, useDingbats = FALSE)
    # Generate all plots for all scenarios with p-values
    plot_all_scenarios(scenario_dataP, scenario_labelsP, 
                       ylim_sr = c(40,100), ylim_abund = c(0,15000))
    plot_all_scenarios(scenario_dataN, scenario_labelsN, 
                       ylim_sr = c(40,100), ylim_abund = c(0,15000))
    plot_all_scenarios(scenario_all, scenario_label_all, 
                       ylim_sr = c(40,100), ylim_abund = c(0,15000))
dev.off()

```

## mutlidemsional plots

```{r}
# Load required libraries
library(ggplot2)
library(dplyr)
library(stringr)
library(gridExtra)

# Assuming your data is in a dataframe called 'res'
# If not, load it first with: res <- read.csv("your_file.csv") or similar

# 1. Plot with meanSR vs slope, colored by int
plot1 <- ggplot(res_all, aes(x = slope, y = meanSR, color = int)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "Intercept") +
  labs(title = "Mean SR vs Slope (colored by intercept)",
       x = "Slope",
       y = "Mean SR") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 2. Plot with meanSR vs slope, colored by cvMC
plot2 <- ggplot(res_all, aes(x = slope, y = meanSR, color = cvMC)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "CV") +
  labs(title = "Mean SR vs Slope (colored by CV)",
       x = "Slope",
       y = "Mean SR") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# Extract parameters from the param column
# Parse the parameter string to extract P, L, C, N values
parse_params <- function(param_string) {
  # Extract P value and its L,C
  p_part <- str_extract(param_string, "P[0-9.]+\\-L[0-9.]+\\-C[0-9]+")
  n_part <- str_extract(param_string, "N[0-9.]+\\-L[0-9.]+\\-C[0-9]+")
  
  # Extract individual values
  P <- as.numeric(str_extract(str_extract(p_part, "P[0-9.]+"), "[0-9.]+"))
  PL <- as.numeric(str_extract(str_extract(p_part, "L[0-9.]+"), "[0-9.]+"))
  PC <- as.numeric(str_extract(str_extract(p_part, "C[0-9]+"), "[0-9]+"))
  
  N <- as.numeric(str_extract(str_extract(n_part, "N[0-9.]+"), "[0-9.]+"))
  NL <- as.numeric(str_extract(str_extract(n_part, "L[0-9.]+"), "[0-9.]+"))
  NC <- as.numeric(str_extract(str_extract(n_part, "C[0-9]+"), "[0-9]+"))
  
  return(data.frame(P = P, PL = PL, PC = PC, N = N, NL = NL, NC = NC))
}

# Apply the parsing function
parsed_params <- do.call(rbind, lapply(res_all$param, parse_params))
res_extended <- cbind(res_all, parsed_params)

# 3. Plot P vs N, colored by meanSR
plot3 <- ggplot(res_extended, aes(x = P, y = N, color = meanSR)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "Mean SR") +
  labs(title = "P vs N (colored by Mean SR)",
       x = "P parameter",
       y = "N parameter") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 4. Plot PL vs NL, colored by meanSR
plot4 <- ggplot(res_extended, aes(x = PL, y = NL, color = meanSR)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "Mean SR") +
  labs(title = "PL vs NL (colored by Mean SR)",
       x = "PL parameter",
       y = "NL parameter") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 5. Plot PC vs NC, colored by meanSR
plot5 <- ggplot(res_extended, aes(x = PC, y = NC, color = meanSR)) +
  geom_jitter(size = 3, alpha = 0.7, width = 0.2, height = 0.2) +
  scale_color_viridis_c(name = "Mean SR") +
  labs(title = "PC vs NC (colored by Mean SR)",
       x = "PC parameter",
       y = "NC parameter") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 6. NEW: Plot P vs PL, colored by meanSR
plot6 <- ggplot(res_extended, aes(x = P, y = PL, color = meanSR)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "Mean SR") +
  labs(title = "P vs PL (colored by Mean SR)",
       x = "P parameter",
       y = "PL parameter") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 7. NEW: Plot N vs NL, colored by meanSR
plot7 <- ggplot(res_extended, aes(x = N, y = NL, color = meanSR)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "Mean SR") +
  labs(title = "N vs NL (colored by Mean SR)",
       x = "N parameter",
       y = "NL parameter") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# Display plots
print(plot1)
print(plot2)
print(plot3)
print(plot4)
print(plot5)
print(plot6)  # New plot
print(plot7)  # New plot

# If you want to save all plots in one figure
combined_plot <- grid.arrange(
  plot3, plot4, plot5,plot6, plot7,
  ncol = 3, nrow = 2,
  top = "Parameter Relationships"
)

# Save plots if needed
# ggsave(paste0(root, "local/figures/ran/meanSR_slope_int_allMax.pdf"), plot1, width = 10, height = 6, dpi = 300)
# ggsave(paste0(root, "local/figures/ran/meanSR_slope_CV_allMax.pdf"), plot2, width = 10, height = 6, dpi = 300)
# ggsave(paste0(root, "local/figures/ran/meanSR_params_allMax.pdf"), combined_plot, width = 15, height = 10, dpi = 300)

```
