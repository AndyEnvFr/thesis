---
title: "PhyloSim Changes"
author: "A.I."
format:
  html:
    number-sections: true
editor: visual
---

```{r}
#| warning: false
library(PhyloSim)
library(parallel)
library(dplyr)
library(tidyverse)
library(lattice)
library(ggplot2)
library(metafor)
library(MASS)
library(viridis)
# root <- "~/Uni/Master/MA/" # work from local machine
root <- "~/cyber_synch/" # work from uni bayreuth server
```

Data is portioned in 3 50-fold-batches for better handling. Therefore, the analysis is repeated three times ranRuns\_\[i,ii,iii\].rds

## Data preparation

```{r}
#| eval: false

runsRaw  <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranRunsFixDC_iii.rds"))
```

```{r}
#| eval: false

# get conspecific neighbors and proper naming
runsRaw  <- getConNeigh(runsRaw, radius = 5)
```

```{r}
# make the runs more slim
runsRaw <- lapply(runsRaw, function(x){
  x$Output <- x$Output[101:200]
  x$Model$runs <- x$Model$runs[101:200]
  return(x)
})
```

```{r}
namesShort <- names(runsRaw) %>%
  stringr::str_remove("_disp.+") %>% 
  stringr::str_replace("Cut", "-C") %>% 
  stringr::str_replace("Cut", "-C") %>% 
  stringr::str_replace("pdd", "P") %>% 
  stringr::str_replace("ndd", "N") %>% 
  stringr::str_replace_all("Var", "-L") %>% 
  stringr::str_replace_all("\\d+\\.\\d{5,}", function(x) substr(x, 1, 6))
```

```{r}
names(runsRaw) <- namesShort
class(runsRaw) <- "PhylosimList"
```

```{r}
S <- getSpecTime(runsRaw, plot = TRUE)
```

Next, we convert the matrix data into tabular data. With the argument detailedParams we include the parameter settings a seperate cols. We save the tabular data.

```{r}
#| eval: false

# convert matrices to tabular data. This is done parallel, as it takes longer
cl <- makeCluster(50)
clusterExport(cl, c("getMatToTab", "runsRaw"))
tab <- parLapply(cl = cl, X = runsRaw, fun = function(x) getMatToTab(x, detailedParams = TRUE))
stopCluster(cl)


# saveRDS(tab, paste0(root, "/local/runs/mstr/20250903/ranTabFixDC_iii.rds"))
```

```{r}
tab <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranTabFixDC_ii.rds"))
```

```{r}
# keep only first timespot in census

cores <- length(tab)
cl <- makeCluster(50)

clusterEvalQ(cl, {
  library(dplyr)
})

tabS <- parLapply(cl, tab, function(x) {
  x %>%
    filter(abund > 100) %>%
    mutate(specIdCen = paste0(specId, census)) %>%
    select(-indId)
})

stopCluster(cl)
```

### Metafor analysis: correcting for uncertainty

```{r}
#| eval: false

cl <- makeCluster(50)

mcS_err <- parLapply(cl, tabS, function(x) {
  specIDs <- unique(x$specIdCen)
  res <- vector("list", length(specIDs))
  
  i <- 1
  for (sID in specIDs) {
    dat <- x[x$specIdCen == sID, ]
    mod <- glm(mortNextGen ~ con, data = dat, family = binomial())
    sfm <- summary(mod)$coefficients
    vc <- vcov(mod)[c("(Intercept)", "con"), c("(Intercept)", "con")]

    mort0 <- plogis(coef(mod)[1])
    mort1 <- plogis(coef(mod)[1] + coef(mod)[2])
    
    res[[i]] <- list(
      specId = sID,
      abund = dat$abund[1],
      mort_change = mort1 - mort0,
      coef = coef(mod)[c(1,2)],
      vcov = vc
    )
    i <- i + 1
  }
  return(res)
})

# Stop the cluster
stopCluster(cl)
```

## compute variance of the marginal effect through a "posterior" simulation

```{r}
#| eval: false

cl <- makeCluster(50)
mcS_err_sim <- parLapply(cl, mcS_err, function(x){
  lapply(x, function(y){
    sim <- MASS::mvrnorm(n = 100, mu = c(y$coef[1], y$coef[2]), Sigma = y$vcov)
    mort0 <- plogis(sim[, 1])
    mort1 <- plogis(sim[, 1] + sim[, 2])
    mort_diff <- mort1 - mort0
    
    return(data.frame(
      abund = y$abund,
      specId = y$specId,
      mean = mean(mort_diff),
      se = sd(mort_diff),
      ci_low = quantile(mort_diff, 0.025),
      ci_high = quantile(mort_diff, 0.975)
    ))
  })
})
# Stop the cluster
stopCluster(cl)
```

## unlist inner lists and add log abund

```{r}
#| eval: false

m4 <- lapply(mcS_err_sim, function(group) {
  do.call(rbind, group)
})

m4 <- lapply(m4, function(group) {
  row.names(group) <- NULL
  group <- group %>% 
    mutate(log_N = log(abund))
  return(group)
})
```

## fitting model

```{r}
#| eval: false

dat_meta <- lapply(m4, function(x) {
  escalc(measure = "GEN", yi = mean, sei = se, slab = specId, data = x)
})
```

```{r}
#| eval: false

# # Detect available cores and create a cluster
# cl <- makeCluster(length(dat_meta))
# 
# # Export needed objects and packages to the workers
# clusterExport(cl, varlist = c("dat_meta"), envir = environment())
# 
# # Run in parallel
# metamod <- parLapply(cl, dat_meta, function(x) {
#   metafor::rma(
#     yi = yi,
#     vi = vi,
#     mods = ~ log_N,
#     method = "REML",
#     data = x
#   )
# })
# 
# # Stop cluster
# stopCluster(cl)
# 
# names(metamod) <- namesShort
```

```{r}
cl <- makeCluster(length(dat_meta))
clusterExport(cl, varlist = c("dat_meta"), envir = environment())

metamod <- parLapply(cl, dat_meta, function(x) {
  tryCatch({
    metafor::rma(
      yi = yi,
      vi = vi,
      mods = ~ log_N,
      method = "REML",
      data = x
    )
  }, error = function(e) {
    return(NULL)  # Return NULL for failed models
  })
})

stopCluster(cl)

# Remove NULL elements and keep names aligned
failed_indices <- sapply(metamod, is.null)
namesShort <- names(metamod)
metamod <- metamod[!failed_indices]
names(metamod) <- namesShort[!failed_indices]

# Report which models failed
if(any(failed_indices)) {
  cat("Failed models:", paste(namesShort[failed_indices], collapse = ", "), "\n")
}
```

```{r}
# deleting one scenario

# saveRDS(dat_meta, paste0(root, "/local/runs/mstr/20250903/ranFixDCDatmetaMax_ii.rds"))
# saveRDS(metamod, paste0(root, "/local/runs/mstr/20250903/ranFixDCMetamodMax_ii.rds"))


metamod <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranFixDCMetamodMax_i.rds"))
datmeta <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranFixDCDatmetaMax_i.rds"))
runsCon <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranRunsFixDC_i.rds"))
```

## predictions

### log_N

```{r}
namesShort <- names(metamod) %>% 
  str_replace("pdd", "P") %>% 
  str_replace("Var", "-L") %>% 
  str_replace("Cut", "-C") %>% 
  str_replace("ndd", "N") %>% 
  str_replace("Var", "-L") %>% 
  str_replace("Cut", "-C") %>% 
  str_remove("_disp1_sr2_fbmr3000_faoM") %>% 
  str_replace_all("([0-9]+\\.[0-9]+)", function(x) sprintf("%.4f", as.numeric(x))
  )

names(metamod) <- namesShort
names(datmeta) <- namesShort
names(runsCon) <- namesShort
```

```{r}
## --- build predictions (as you had) ---
pred <- lapply(datmeta, function(x){
  expand_grid(log_N = seq(min(x$log_N, na.rm = TRUE),
                          max(x$log_N, na.rm = TRUE),
                          length.out = 1000))
})
pred <- lapply(pred, function(x){
  x$abund <- exp(x$log_N)
  x
})
pred <- lapply(seq_along(pred), function(i){
  x <- pred[[i]]
  y <- metamod[[i]]
  cbind(x, predict(object = y, newmods = x$log_N))
})
names(pred) <- namesShort  # <- your vector like the one you listed

srRaw <- getSpecTime(runsCon, plot = FALSE)

# Get slopes
slope <- map_dbl(metamod, ~ coef(.x)[2]) %>%
  enframe(name = "param", value = "slope")

# Get standard error of slopes
seSlope <- map_dbl(metamod, ~ se(.x)[2]) %>%
  enframe(name = "param", value = "seSlope")

# Get abundance (use max to exclude extreme values)
abund <- map_dbl(datmeta, ~ max(.x$abund)) %>%
  enframe(name = "param", value = "abund")

# Get CV of predictions
cv <- map(pred, ~ {
  meanMC <- mean(.x$pred)
  sdMC <- sd(.x$pred)
  rangeMC <- diff(range(.x$pred))
  tibble(meanMC = meanMC, sdMC = sdMC, rangeMC = rangeMC, cvMC = sdMC / meanMC)
}) %>%
  bind_rows(.id = "param")

# Get species richness summary
sr <- map(srRaw, ~ {
  vals <- .x$spec_rich[99:200]
  tibble(
    meanSR = mean(vals),
    sdSR = sd(vals),
    medianSR = median(vals)
  )
}) %>%
  bind_rows(.id = "param") %>%
  mutate(medianSR = as.integer(medianSR))

# Combine all results
res <- list(slope, seSlope, sr, abund, cv) %>%
  reduce(left_join, by = "param") %>%
  mutate(abund = as.integer(abund))

# Filter by scenario types
scenario_comps <- paste0("C", 1:5)

res_scenarios <- map(scenario_comps, ~ {
  pattern <- paste0(".*-", .x)  # matches both P and N runs
  res %>% filter(grepl(pattern, param))
}) %>%
  set_names(scenario_comps)
```

```{r}
#| fig-width: 7
#| fig-height: 7
#| fig-cap: ["Relationships between stabilizing CDD parameters and community diversity metrics for randomly sampled nDD and pDD scenarios. A linear regression with 95% confidence intervals is fitted for the data in the corresponding panels and corresponding P values provided. Data is sorted by nDD spatial kernel (= nDC) and pdd(= pDC), except the last plot that contains all combined data. The slope (x-axis top-left and -right) results from the metaregression (see above) between stabilizing CDD and species abundance - the more negative it is, the stronger the negative relationship. Mean species richness is averaged across one run after filtering out non-equilibrium generations. Max abundance is the maximum abundance of any species within one run. CV is the coefficient of variation calculated by standard deviation of stabilizing CDD divided by mean stabilizing CDD. Top-left: Mean species richness vs slope. Top-right: Maximum abundance vs slope with log-transformed model fit. Bottom-left: Mean species richness vs CV stabilizing CDD (%) colored by slope values. Bottom-right: Mean species richness vs mean stabilizing CDD (%) with log-transformed relationship and slope-colored points.","","","","","","","","","",""]

## ---- helper functions ----
pred_lm_log <- function(mod, newdata, k = 2) {
  pred <- predict(mod, newdata = newdata, se.fit = TRUE)
  fit <- exp(pred$fit)
  lo  <- exp(pred$fit - k*pred$se.fit)
  hi  <- exp(pred$fit + k*pred$se.fit)
  list(fit = fit, lo = lo, hi = hi)
}

# Helper function to format p-values
format_pvalue <- function(p) {
  if (p < 0.001) {
    return("p < 0.001")
  } else if (p < 0.01) {
    return(sprintf("p = %.3f", p))
  } else {
    return(sprintf("p = %.2f", p))
  }
}

# Unified function for species richness vs slope plot (AXES REVERSED)
plot_sr_slope <- function(dat, tag, xlim_sr = c(40,100)) {
  fm1 <- lm(meanSR ~ slope, data = dat)
  newdat <- data.frame(slope = seq(min(dat$slope), max(dat$slope), length = 100))
  predi <- predict(fm1, newdata = newdat, se.fit = TRUE)
  
  # Extract p-value
  p_val <- summary(fm1)$coefficients[2, 4]  # p-value for slope coefficient
  p_text <- format_pvalue(p_val)
  
  plot(dat$meanSR, dat$slope, xlim = xlim_sr, pch = 16, col = "blue", cex = .8,
       ylab = "slope of fitted meta regression", xlab = "mean species richness")
  points(dat$medianSR, dat$slope, pch = 16, cex = .8, col = "red")
  
  # Vertical error bars for seSlope (was horizontal)
  arrows(dat$meanSR, dat$slope - dat$seSlope, dat$meanSR, dat$slope + dat$seSlope,
         angle = 90, code = 3, length = 0.05, lwd = .5, col = rgb(0,0,0,.5))
  # Horizontal error bars for sdSR (was vertical)
  arrows(dat$meanSR - dat$sdSR, dat$slope, dat$meanSR + dat$sdSR, dat$slope,
         angle = 90, code = 3, length = 0.05, col = rgb(0,0,0,.5))
  
  lines(predi$fit, newdat$slope, lwd = 2, col = 1)
  lines(predi$fit - 2*predi$se.fit, newdat$slope, lwd = 1, lty = 2, col = 1)
  lines(predi$fit + 2*predi$se.fit, newdat$slope, lwd = 1, lty = 2, col = 1)
  legend("topright", legend = c("mean species richness", "median species richness"),
         pch = c(16,16), col = c(4,2), bty = "n")
  
  # Add p-value text
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Unified function for abundance vs slope plot (AXES REVERSED)
plot_abund_slope <- function(dat, tag) {
  # Log-transform abundance (add 1 to avoid log(0))
  dat$log_abund <- log(dat$abund)
  # Fit linear model on log(abundance)
  fm <- lm(log_abund ~ slope, data = dat)
  # Prediction along slope range
  newdat <- data.frame(slope = seq(min(dat$slope), max(dat$slope), length = 100))
  pg <- pred_lm_log(fm, newdat, k = 2)
  # Extract p-value for slope
  p_val <- summary(fm)$coefficients[2, 4]
  p_text <- format_pvalue(p_val)
  # Plot log-transformed abundances (axes reversed)
  plot(dat$log_abund, dat$slope, pch = 16, col = 1, cex = .8,
       ylab = "slope of fitted meta regression", xlab = "log(max abundance)")
  
  # Vertical error bars for seSlope (was horizontal)
  arrows(dat$log_abund, dat$slope - dat$seSlope, dat$log_abund, dat$slope + dat$seSlope,
         angle = 90, code = 3, length = 0.05, lwd = .5, col = rgb(0,0,0,.5))
  
  # Add fitted line and confidence intervals
  lines(log(pg$fit), newdat$slope, lwd = 2, col = 1)
  lines(log(pg$lo), newdat$slope, lwd = 1, lty = 2, col = 1)
  lines(log(pg$hi), newdat$slope, lwd = 1, lty = 2, col = 1)
  # Add p-value text
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Unified function for species richness vs CV mortality change (AXES REVERSED)
plot_sr_cvmc <- function(dat, tag, xlim_sr = c(40,90)) {
  fm3 <- lm(meanSR ~ cvMC, data = dat)
  newdat <- data.frame(cvMC = seq(min(dat$cvMC), max(dat$cvMC), length = 100))
  pred <- predict(fm3, newdata = newdat, se.fit = TRUE)
  
  # Extract p-value
  p_val <- summary(fm3)$coefficients[2, 4]  # p-value for cvMC coefficient
  p_text <- format_pvalue(p_val)
  
  cols <- viridis(length(dat$slope))[rank(dat$slope)]
  cols_error <- cols %>% adjustcolor(alpha.f = 0.75)
  plot(dat$meanSR, dat$cvMC, xlim = xlim_sr, pch = 16, col = cols, cex = .8,
       ylab = "CV of stabilizing CDD", xlab = "mean species richness")
  arrows(dat$meanSR - dat$sdSR, dat$cvMC, dat$meanSR + dat$sdSR, dat$cvMC,
         angle = 90, code = 3, length = 0.05, col = cols_error, lwd =.5)
  lines(pred$fit, newdat$cvMC, lwd = 2, col = 1)
  lines(pred$fit - 2*pred$se.fit, newdat$cvMC, lwd = 1, lty = 2, col = 1)
  lines(pred$fit + 2*pred$se.fit, newdat$cvMC, lwd = 1, lty = 2, col = 1)
  legend("topright", title = "slope",
         fill = viridis(5),
         legend = signif(seq(min(dat$slope), max(dat$slope), length.out = 5), 2),
         bty = "n", cex = .8)
  
  # Add p-value text
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Unified function for species richness vs mean stabilizing CDD (AXES REVERSED)
plot_sr_meanmc <- function(dat, tag, xlim_sr = c(40,90)) {
  fm4 <- lm(meanSR ~ meanMC, data = dat)
  newdat <- data.frame(meanMC = seq(min(dat$meanMC), max(dat$meanMC), length = 100))
  pred <- predict(fm4, newdata = newdat, se.fit = TRUE)
  
  # Extract p-value
  p_val <- summary(fm4)$coefficients[2, 4]  # p-value for log(meanMC) coefficient
  p_text <- format_pvalue(p_val)
  
  cols <- viridis(length(dat$slope))[rank(dat$slope)]
  cols_error <- cols %>% adjustcolor(alpha.f = .75)
  plot(dat$meanSR, dat$meanMC, xlim = xlim_sr, pch = 16, col = cols, cex = .8,
       ylab = "mean stabilizing CDD (%)", xlab = "mean species richness")
  # Vertical error bars for sdMC (was horizontal)
  arrows(dat$meanSR, dat$meanMC - dat$sdMC, dat$meanSR, dat$meanMC + dat$sdMC,
         angle = 90, code = 3, length = 0.05, lwd = .5, col = cols_error)
  lines(pred$fit, newdat$meanMC, lwd = 2, col = 1)
  lines(pred$fit - 2*pred$se.fit, newdat$meanMC, lwd = 1, lty = 2, col = 1)
  lines(pred$fit + 2*pred$se.fit, newdat$meanMC, lwd = 1, lty = 2, col = 1)
  legend("bottomright", title = "slope",
         fill = viridis(5),
         legend = signif(seq(min(dat$slope), max(dat$slope), length.out = 5), 2),
         bty = "n", cex = .8)
  
  # Add p-value text
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]),  
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Master plotting function for all scenario plots (4 plot types per scenario)
plot_all_scenarios <- function(scenario_list, scenario_names, 
                              xlim_sr = c(40,100)) {
  n_scenarios <- length(scenario_list)
  
  # For each scenario, create all 4 plot types
  for(i in 1:n_scenarios) {
    # Set up 2x2 grid for each scenario with main title
    # par(mfrow = c(2, 2), mar = c(4,4,3,2), oma = c(0, 0, 2, 0))       # change this for single or mulit-panel plots
    par(mfrow = c(1, 1), mar = c(6,4,3,2), oma = c(0, 0, 2, 0))       # change this for single or mulit-panel plots
    
    # Main analysis plots
    plot_sr_slope(scenario_list[[i]], scenario_names[i], xlim_sr)
    plot_abund_slope(scenario_list[[i]], scenario_names[i])
    plot_sr_cvmc(scenario_list[[i]], scenario_names[i], xlim_sr)
    plot_sr_meanmc(scenario_list[[i]], scenario_names[i], xlim_sr)
    
    # Add main title for the entire 4-panel plot
    mtext(scenario_names[i], outer = TRUE, cex = 1.5, font = 2)
  }
}

## ---- apply to scenarios C1-C5 ----
# Assuming you have data objects: resC1, resC2, resC3, resC4, resC5
# scenario_data1<- res_scenarios[str_detect(string = names(res_scenarios),pattern = "1")]
# scenario_label1 <- "DC = 1"
# scenario_data2<- res_scenarios[str_detect(string = names(res_scenarios),pattern = "2")]
# scenario_label2 <- "DC = 2"
# scenario_data3<- res_scenarios[str_detect(string = names(res_scenarios),pattern = "3")]
# scenario_label3 <- "DC = 3"
# scenario_data4<- res_scenarios[str_detect(string = names(res_scenarios),pattern = "4")]
# scenario_label4 <- "DC = 4"
# scenario_data5<- res_scenarios[str_detect(string = names(res_scenarios),pattern = "5")]
# scenario_label5 <- "DC = 5"

# # Generate all plots for negative scenarios
# plot_all_scenarios(scenario_data1, scenario_label1,
#                    ylim_sr = c(40,100))
# plot_all_scenarios(scenario_data2, scenario_label2,
#                    ylim_sr = c(40,100))
# plot_all_scenarios(scenario_data3, scenario_label3,
#                    ylim_sr = c(40,100))
# plot_all_scenarios(scenario_data4, scenario_label4,
#                    ylim_sr = c(40,100))
# plot_all_scenarios(scenario_data5, scenario_label5,
#                    ylim_sr = c(40,100))
# 
# # Generate plot for combined data
# plot_all_scenarios(list(res), "combined data", 
#                    ylim_sr = c(40,100))
```

```{r}
# saveRDS(res, paste0(root, "/local/runs/mstr/20250903/ranResFixDC_i.rds"))
```

```{r}
#| fig-width: 7
#| fig-height: 7
#| fig-cap: "Relationships between stabilizing CDD parameters and community diversity metrics for randomly sampled nDD and pDD scenarios. A linear regression with 95% confidence intervals is fitted for the data in the corresponding panels. Data comes from 150 runs with randomly sampled parametrization. The slope results from the metaregression and encapsulates the relationship between stabilizing CDD and species abundance - the more negative it is, the stronger the negative relationship. Mean species richness is averaged across one run after filtering out non-equilibrium generations. Max abundance is the maximum abundance of any species within one run. CV is the coefficient of variation calculated by standard deviation of stabilizing CDD divided by mean stabilizing CDD. Top-left: Mean species richness vs slope. Top-right: Maximum abundance vs slope with log-transformed model fit. Bottom-left: Mean species richness vs CV stabilizing CDD (%) colored by slope values. Bottom-right: Mean species richness vs mean stabilizing CDD (%) with log-transformed relationship and slope-colored points."

# resi <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResFixDC_i.rds"))
# resii <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResFixDC_ii.rds"))
# resiii <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResFixDC_iii.rds"))
# 
# res_all <- rbind(resi,resii,resiii)

resi <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResMax_i.rds"))
resii <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResMax_ii.rds"))
resiii <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResMax_iii.rds"))

res_all <- rbind(resi,resii,resiii)

# # Generate plot for combined data
# plot_all_scenarios(list(res_all), "",
#                    ylim_sr = c(40,100))

# 
# pdf(paste0(root, "local/figures/ran/ran_allMax.pdf"), width = 5, height = 5, onefile = TRUE, useDingbats = FALSE)
plot_all_scenarios(list(res_all), "", xlim_sr = c(40,90))
# dev.off()
```



```{r}
pred_lm_log <- function(mod, newdata, k = 2) {
  pred <- predict(mod, newdata = newdata, se.fit = TRUE)
  fit <- exp(pred$fit)
  lo  <- exp(pred$fit - k*pred$se.fit)
  hi  <- exp(pred$fit + k*pred$se.fit)
  list(fit = fit, lo = lo, hi = hi)
}

# Helper function to format p-values
format_pvalue <- function(p) {
  if (p < 0.001) {
    return("p < 0.001")
  } else if (p < 0.01) {
    return(sprintf("p = %.3f", p))
  } else {
    return(sprintf("p = %.3f", p))
  }
}

# Updated function for species richness vs slope plot - SWAPPED AXES
plot_sr_slope <- function(dat, tag, ylim_sr = c(40,100)) {
  # Meta-regression with escalc
  DM <- metafor::escalc(measure = "GEN", yi = slope, sei = seSlope, data = dat)
  fm1 <- metafor::rma(yi = yi, vi = vi, mods = ~ meanSR, method = "REML", data = DM)
  
  # Generate predictions
  newdat <- data.frame(meanSR = seq(min(DM$meanSR, na.rm = TRUE), 
                                     max(DM$meanSR, na.rm = TRUE), 
                                     length.out = 100))
  pred <- predict(object = fm1, newmods = newdat$meanSR)
  
  # Extract p-value
  p_val <- summary(fm1)$pval[2]  # p-value for meanSR coefficient
  p_text <- format_pvalue(p_val)
  
  # Plot (SR on x-axis, slope on y-axis) - SWAPPED
  plot(dat$meanSR, dat$slope, xlim = ylim_sr, pch = 16, col = "black", cex = .5,
       ylab = "slope of fitted meta regression", xlab = "mean species richness",
       cex.lab = 1.6, cex.axis = 1.2, mgp = c(2.5, 1, 0))
  
  # Vertical error bars for seSlope - SWAPPED
  arrows(dat$meanSR, dat$slope - dat$seSlope, dat$meanSR, dat$slope + dat$seSlope,
         angle = 90, code = 3, length = 0.05, lwd = .5, col = rgb(0,0,0,.2))
  
  # Horizontal error bars for sdSR - SWAPPED
  arrows(dat$meanSR - dat$sdSR, dat$slope, dat$meanSR + dat$sdSR, dat$slope,
         angle = 90, code = 3, length = 0.05, col = rgb(0,0,0,.2))
  
  # Add fitted line and confidence intervals - SWAPPED
  lines(newdat$meanSR, pred$pred, lwd = 2, col = 1)
  lines(newdat$meanSR, pred$ci.lb, lwd = 1, lty = 2, col = 1)
  lines(newdat$meanSR, pred$ci.ub, lwd = 1, lty = 2, col = 1)
  
  # Add p-value text (upright position)
  text(x = par("usr")[2] - 0.02 * diff(par("usr")[1:2]),
       y = par("usr")[3] + 0.95 * diff(par("usr")[3:4]),
       labels = p_text, pos = 2, cex = 1.2, col = "black")
}

# Updated function for abundance vs slope plot using meta-regression
plot_abund_slope <- function(dat, tag) {
  # Log-transform abundance
  dat$log_abund <- log(dat$abund)
  
  # Meta-regression with escalc
  DM <- metafor::escalc(measure = "GEN", yi = slope, sei = seSlope, data = dat)
  fm2 <- metafor::rma(yi = yi, vi = vi, mods = ~ log_abund, method = "REML", data = DM)
  
  # Generate predictions
  newdat <- data.frame(log_abund = seq(min(DM$log_abund, na.rm = TRUE), 
                                        max(DM$log_abund, na.rm = TRUE), 
                                        length.out = 100))
  pred <- predict(object = fm2, newmods = newdat$log_abund)
  
  # Extract p-value
  p_val <- summary(fm2)$pval[2]  # p-value for log_abund coefficient
  p_text <- format_pvalue(p_val)
  
  # Plot (slope on x-axis, log_abund on y-axis)
  plot(dat$log_abund, dat$slope, pch = 16, col = 1, cex = .5,
       ylab = "slope of fitted meta regression", xlab = "log(max abundance)",
       cex.lab = 1.6, cex.axis = 1.2, mgp = c(2.5, 1, 0))
  
  # Horizontal error bars for seSlope
  arrows(dat$log_abund,
       dat$slope - dat$seSlope,
       dat$log_abund,
       dat$slope + dat$seSlope,
       angle = 90, code = 3, length = 0.05, lwd = .5, col = rgb(0,0,0,.2))
  
  # Add fitted line and confidence intervals - plot pred vs newdat
  lines(newdat$log_abund, pred$pred, lwd = 2, col = 1)
  lines(newdat$log_abund, pred$ci.lb, lwd = 1, lty = 2, col = 1)
  lines(newdat$log_abund, pred$ci.ub, lwd = 1, lty = 2, col = 1)
  
  # Add p-value text (topleft)
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]),
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]),
       labels = p_text, pos = 4, cex = 1.2, col = "black")
}

# Unified function for species richness vs CV mortality change - SWAPPED AXES
plot_sr_cvmc <- function(dat, tag, ylim_sr = c(40,90)) {
  # Fit model with meanSR as predictor
  fm3 <- lm(cvMC ~ meanSR, data = dat)
  newdat <- data.frame(meanSR = seq(min(dat$meanSR), max(dat$meanSR), length = 100))
  pred <- predict(fm3, newdata = newdat, se.fit = TRUE)
  
  # Extract p-value
  p_val <- summary(fm3)$coefficients[2, 4]  # p-value for meanSR coefficient
  p_text <- format_pvalue(p_val)
  
  cols <- viridis(length(dat$slope))[rank(dat$slope)]
  cols_error <- cols %>% adjustcolor(alpha.f = 0.75)
  
  # Plot with SR on x-axis and cvMC on y-axis - SWAPPED
  plot(dat$meanSR, dat$cvMC, xlim = ylim_sr, pch = 16, col = cols, cex = .5,
       xlab = "mean species richness", ylab = "CV of stabilizing CDD",
       cex.lab = 1.6, cex.axis = 1.2, mgp = c(2.5, 1, 0))
  
  # Horizontal error bars for sdSR - SWAPPED
  arrows(dat$meanSR - dat$sdSR, dat$cvMC, dat$meanSR + dat$sdSR, dat$cvMC,
         angle = 90, code = 3, length = 0.05, col = cols_error, lwd = .5)
  
  # Add fitted line and confidence intervals
  lines(newdat$meanSR, pred$fit, lwd = 2, col = 1)
  lines(newdat$meanSR, pred$fit - 2*pred$se.fit, lwd = 1, lty = 2, col = 1)
  lines(newdat$meanSR, pred$fit + 2*pred$se.fit, lwd = 1, lty = 2, col = 1)
  
  legend("topleft", title = "slope",
         fill = viridis(5),
         legend = signif(seq(min(dat$slope), max(dat$slope), length.out = 5), 2),
         bty = "n", cex = 1.0, pt.cex = 1, text.col = "black", ncol = 1,
         title.cex = 1)
  
  # Add p-value text (topleft)
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]),
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]),
       labels = p_text, pos = 4, cex = 1.2, col = "black")
}

# Updated function for species richness vs mean stabilizing CDD - AXES ALREADY CORRECT
plot_sr_meanmc <- function(dat, tag, ylim_sr = c(40,90)) {
  # Meta-regression with escalc
  DM <- metafor::escalc(measure = "GEN", yi = meanMC, sei = sdMC, data = dat)
  fm4 <- metafor::rma(yi = yi, vi = vi, mods = ~ meanSR, method = "REML", data = DM)
  
  # Generate predictions
  newdat <- data.frame(meanSR = seq(min(DM$meanSR, na.rm = TRUE), 
                                     max(DM$meanSR, na.rm = TRUE), 
                                     length.out = 100))
  pred <- predict(object = fm4, newmods = newdat$meanSR)
  
  # Extract p-value
  p_val <- summary(fm4)$pval[2]  # p-value for meanSR coefficient
  p_text <- format_pvalue(p_val)
  
  cols <- viridis(length(dat$slope))[rank(dat$slope)]
  cols_error <- cols %>% adjustcolor(alpha.f = .75)
  
  # Plot (SR on x-axis, meanMC on y-axis) - SWAPPED
  plot(dat$meanSR, dat$meanMC, xlim = ylim_sr, pch = 16, col = cols, cex = .5,
       xlab = "mean species richness", ylab = "mean stabilizing CDD (%)",
       cex.lab = 1.6, cex.axis = 1.2, mgp = c(2.5, 1, 0))
  
  # Horizontal error bars for sdSR - SWAPPED
  arrows(dat$meanSR - dat$sdSR, dat$meanMC, dat$meanSR + dat$sdSR, dat$meanMC,
         angle = 90, code = 3, length = 0.05, lwd = .5, col = cols_error)
  
  # Vertical error bars for sdMC - SWAPPED
  arrows(dat$meanSR, dat$meanMC - dat$sdMC, dat$meanSR, dat$meanMC + dat$sdMC,
         angle = 90, code = 3, length = 0.05, lwd = .5, col = cols_error)
  
  # Add fitted line and confidence intervals - SWAPPED
  lines(newdat$meanSR, pred$pred, lwd = 2, col = 1)
  lines(newdat$meanSR, pred$ci.lb, lwd = 1, lty = 2, col = 1)
  lines(newdat$meanSR, pred$ci.ub, lwd = 1, lty = 2, col = 1)
  
  legend("topleft", title = "slope", ncol = 1,
         fill = viridis(5),
         legend = signif(seq(min(dat$slope), max(dat$slope), length.out = 5), 2),
         cex = 1.0, pt.cex = 1, bty = "n", title.cex = 1)
  
  # Add p-value text (topleft)
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]),
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]),
       labels = p_text, pos = 4, cex = 1.2, col = "black")
}

# Master plotting function for all scenario plots (4 plot types per scenario)
plot_all_scenarios <- function(scenario_list, scenario_names, 
                              ylim_sr = c(40,100)) {
  n_scenarios <- length(scenario_list)
  
  # For each scenario, create all 4 plot types
  for(i in 1:n_scenarios) {
    # Set up 2x2 grid for each scenario with main title
    # par(mfrow = c(2, 2), mar = c(4,4,3,2), oma = c(0, 0, 2, 0))       # change this for single or mulit-panel plots
    par(mfrow = c(1, 1), mar = c(6,4,3,2), oma = c(0, 0, 2, 0))       # change this for single or mulit-panel plots
    
    # Main analysis plots
    plot_sr_slope(scenario_list[[i]], scenario_names[i], ylim_sr)
    plot_abund_slope(scenario_list[[i]], scenario_names[i])
    plot_sr_cvmc(scenario_list[[i]], scenario_names[i], ylim_sr)
    plot_sr_meanmc(scenario_list[[i]], scenario_names[i], ylim_sr)
    
    # Add main title for the entire 4-panel plot
    mtext(scenario_names[i], outer = TRUE, cex = 1.5, font = 2)
  }
}
```

```{r}
#| fig-width: 4
#| fig-height: 5
#| fig-cap: "Relationships between stabilizing CDD parameters and community diversity metrics for randomly sampled nDD and pDD scenarios. A linear regression with 95% confidence intervals is fitted for the data in the corresponding panels. Data comes from 150 runs with randomly sampled parametrization. The slope results from the metaregression and encapsulates the relationship between stabilizing CDD and species abundance - the more negative it is, the stronger the negative relationship. Mean species richness is averaged across one run after filtering out non-equilibrium generations. Max abundance is the maximum abundance of any species within one run. CV is the coefficient of variation calculated by standard deviation of stabilizing CDD divided by mean stabilizing CDD. Top-left: Mean species richness vs slope. Top-right: Maximum abundance vs slope with log-transformed model fit. Bottom-left: Mean species richness vs CV stabilizing CDD (%) colored by slope values. Bottom-right: Mean species richness vs mean stabilizing CDD (%) with log-transformed relationship and slope-colored points."

resi <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResFixDC_i.rds"))
resii <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResFixDC_ii.rds"))
resiii <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResFixDC_iii.rds"))
# 
# res_all <- rbind(resi,resii,resiii)

# resi <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResMax_i.rds"))
# resii <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResMax_ii.rds"))
# resiii <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResMax_iii.rds"))

res_all <- rbind(resi,resii,resiii)

# # Generate plot for combined data
# plot_all_scenarios(list(res_all), "",
#                    ylim_sr = c(40,100))

# 
# pdf(paste0(root, "local/figures/ran/ran_finalP.pdf"), width = 5, height = 5, onefile = TRUE, useDingbats = FALSE)
# plot_all_scenarios(list(res_all), "",
                   # ylim_sr = c(40,90))
# dev.off()

```

```{r}
#| fig-height: 5
#| fig-width: 4

# pdf(paste0(root, "local/figures/ran/ran_finalALT.pdf"), width = 4, height = 5, onefile = TRUE, useDingbats = FALSE)
plot_all_scenarios(list(res_all), "",
                   ylim_sr = c(40,90))
# dev.off()
```






<!-- # last plot changed: max species abund instead of mean species richness -->

<!-- ```{r} -->
<!-- ## ---- helper functions ---- -->
<!-- pred_lm_log <- function(mod, newdata, k = 2) { -->
<!--   pred <- predict(mod, newdata = newdata, se.fit = TRUE) -->
<!--   fit <- exp(pred$fit) -->
<!--   lo  <- exp(pred$fit - k*pred$se.fit) -->
<!--   hi  <- exp(pred$fit + k*pred$se.fit) -->
<!--   list(fit = fit, lo = lo, hi = hi) -->
<!-- } -->

<!-- # Helper function to format p-values -->
<!-- format_pvalue <- function(p) { -->
<!--   if (p < 0.001) { -->
<!--     return("p < 0.001") -->
<!--   } else if (p < 0.01) { -->
<!--     return(sprintf("p = %.3f", p)) -->
<!--   } else { -->
<!--     return(sprintf("p = %.2f", p)) -->
<!--   } -->
<!-- } -->

<!-- # Updated function for species richness vs slope plot using meta-regression -->
<!-- plot_sr_slope <- function(dat, tag, ylim_sr = c(40,100)) { -->
<!--   # Meta-regression with escalc -->
<!--   DM <- metafor::escalc(measure = "GEN", yi = slope, sei = seSlope, data = dat) -->
<!--   fm1 <- metafor::rma(yi = yi, vi = vi, mods = ~ meanSR, method = "REML", data = DM) -->

<!--   # Generate predictions -->
<!--   newdat <- data.frame(meanSR = seq(min(DM$meanSR, na.rm = TRUE),  -->
<!--                                      max(DM$meanSR, na.rm = TRUE),  -->
<!--                                      length.out = 100)) -->
<!--   pred <- predict(object = fm1, newmods = newdat$meanSR) -->

<!--   # Extract p-value -->
<!--   p_val <- summary(fm1)$pval[2]  # p-value for meanSR coefficient -->
<!--   p_text <- format_pvalue(p_val) -->

<!--   # Plot (slope on x-axis, SR on y-axis) -->
<!--   plot(dat$slope, dat$meanSR, ylim = ylim_sr, pch = 16, col = "blue", cex = .8, -->
<!--        xlab = "slope of fitted meta regression", ylab = "mean species richness") -->
<!--   points(dat$slope, dat$medianSR, pch = 16, cex = .8, col = "red") -->

<!--   # Horizontal error bars for seSlope -->
<!--   arrows(dat$slope - dat$seSlope, dat$meanSR, dat$slope + dat$seSlope, dat$meanSR, -->
<!--          angle = 90, code = 3, length = 0.05, lwd = .5, col = rgb(0,0,0,.5)) -->

<!--   # Vertical error bars for sdSR -->
<!--   arrows(dat$slope, dat$meanSR - dat$sdSR, dat$slope, dat$meanSR + dat$sdSR, -->
<!--          angle = 90, code = 3, length = 0.05, col = rgb(0,0,0,.5)) -->

<!--   # Add fitted line and confidence intervals - need to plot pred vs newdat -->
<!--   lines(pred$pred, newdat$meanSR, lwd = 2, col = 1) -->
<!--   lines(pred$ci.lb, newdat$meanSR, lwd = 1, lty = 2, col = 1) -->
<!--   lines(pred$ci.ub, newdat$meanSR, lwd = 1, lty = 2, col = 1) -->

<!--   legend("topright", legend = c("mean species richness", "median species richness"), -->
<!--          pch = c(16,16), col = c(4,2), bty = "n") -->

<!--   # Add p-value text -->
<!--   text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]),  -->
<!--        y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]),  -->
<!--        labels = p_text, pos = 4, cex = 0.9, col = "darkred") -->
<!-- } -->

<!-- # Unified function for abundance vs slope plot (WITH HORIZONTAL ERROR BARS) -->
<!-- plot_abund_slope <- function(dat, tag) { -->
<!--   # Log-transform abundance (add 1 to avoid log(0)) -->
<!--   dat$log_abund <- log(dat$abund) -->
<!--   # Fit linear model on log(abundance) -->
<!--   fm <- lm(log_abund ~ slope, data = dat) -->
<!--   # Prediction along slope range -->
<!--   newdat <- data.frame(slope = seq(min(dat$slope), max(dat$slope), length = 100)) -->
<!--   pg <- pred_lm_log(fm, newdat, k = 2) -->
<!--   # Extract p-value for slope -->
<!--   p_val <- summary(fm)$coefficients[2, 4] -->
<!--   p_text <- format_pvalue(p_val) -->
<!--   # Plot log-transformed abundances -->
<!--   plot(dat$slope, dat$log_abund, pch = 16, col = 1, cex = .8, -->
<!--        xlab = "slope of fitted meta regression", ylab = "log(max abundance)") -->

<!--   # Horizontal error bars for seSlope (NEW) -->
<!--   arrows(dat$slope - dat$seSlope, dat$log_abund, dat$slope + dat$seSlope, dat$log_abund, -->
<!--          angle = 90, code = 3, length = 0.05,lwd = .5, col = rgb(0,0,0,.5)) -->

<!--   # Add fitted line and confidence intervals -->
<!--   lines(newdat$slope, log(pg$fit), lwd = 2, col = 1) -->
<!--   lines(newdat$slope, log(pg$lo), lwd = 1, lty = 2, col = 1) -->
<!--   lines(newdat$slope, log(pg$hi), lwd = 1, lty = 2, col = 1) -->
<!--   # Add legend -->
<!--   # Add p-value text -->
<!--   text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]),  -->
<!--        y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]),  -->
<!--        labels = p_text, pos = 4, cex = 0.9, col = "darkred") -->
<!-- } -->

<!-- # Unified function for species richness vs CV mortality change (unchanged) -->
<!-- plot_sr_cvmc <- function(dat, tag, ylim_sr = c(40,90)) { -->
<!--   fm3 <- lm(meanSR ~ cvMC, data = dat) -->
<!--   newdat <- data.frame(cvMC = seq(min(dat$cvMC), max(dat$cvMC), length = 100)) -->
<!--   pred <- predict(fm3, newdata = newdat, se.fit = TRUE) -->

<!--   # Extract p-value -->
<!--   p_val <- summary(fm3)$coefficients[2, 4]  # p-value for cvMC coefficient -->
<!--   p_text <- format_pvalue(p_val) -->

<!--   cols <- viridis(length(dat$slope))[rank(dat$slope)] -->
<!--   cols_error <- cols %>% adjustcolor(alpha.f = 0.75) -->
<!--   plot(dat$cvMC, dat$meanSR, ylim = ylim_sr, pch = 16, col = cols, cex = .8, -->
<!--        xlab = "CV of stabilizing CDD", ylab = "mean species richness") -->
<!--   arrows(dat$cvMC, dat$meanSR - dat$sdSR, dat$cvMC, dat$meanSR + dat$sdSR, -->
<!--          angle = 90, code = 3, length = 0.05, col = cols_error, lwd =.5) -->
<!--   lines(newdat$cvMC, pred$fit, lwd = 2, col = 1) -->
<!--   lines(newdat$cvMC, pred$fit - 2*pred$se.fit, lwd = 1, lty = 2, col = 1) -->
<!--   lines(newdat$cvMC, pred$fit + 2*pred$se.fit, lwd = 1, lty = 2, col = 1) -->
<!--   legend("topright", title = "slope", -->
<!--          fill = viridis(5), -->
<!--          legend = signif(seq(min(dat$slope), max(dat$slope), length.out = 5), 2), -->
<!--          bty = "n", cex = .8) -->

<!--   # Add p-value text -->
<!--   text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]),  -->
<!--        y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]),  -->
<!--        labels = p_text, pos = 4, cex = 0.9, col = "darkred") -->
<!-- } -->

<!-- # Updated function for max abundance vs mean stabilizing CDD using meta-regression -->
<!-- plot_sr_meanmc <- function(dat, tag, ylim_sr = c(40,90)) { -->
<!--   # Log-transform abundance -->
<!--   dat$log_abund <- log(dat$abund) -->

<!--   # Meta-regression with escalc -->
<!--   DM <- metafor::escalc(measure = "GEN", yi = meanMC, sei = sdMC, data = dat) -->
<!--   DM$log_abund <- dat$log_abund -->
<!--   fm4 <- metafor::rma(yi = yi, vi = vi, mods = ~ log_abund, method = "REML", data = DM) -->

<!--   # Generate predictions -->
<!--   newdat <- data.frame(log_abund = seq(min(DM$log_abund, na.rm = TRUE),  -->
<!--                                         max(DM$log_abund, na.rm = TRUE),  -->
<!--                                         length.out = 100)) -->
<!--   pred <- predict(object = fm4, newmods = newdat$log_abund) -->

<!--   # Extract p-value -->
<!--   p_val <- summary(fm4)$pval[2]  # p-value for log_abund coefficient -->
<!--   p_text <- format_pvalue(p_val) -->

<!--   cols <- viridis(length(dat$slope))[rank(dat$slope)] -->
<!--   cols_error <- cols %>% adjustcolor(alpha.f = .75) -->

<!--   # Plot (meanMC on x-axis, log abundance on y-axis) -->
<!--   plot(dat$meanMC, dat$log_abund, pch = 16, col = cols, cex = .8, -->
<!--        xlab = "mean stabilizing CDD (%)", ylab = "log(max abundance)") -->

<!--   # Horizontal error bars for sdMC -->
<!--   arrows(dat$meanMC - dat$sdMC, dat$log_abund, dat$meanMC + dat$sdMC, dat$log_abund, -->
<!--          angle = 90, code = 3, length = 0.05, lwd = .5, col = cols_error) -->

<!--   # Add fitted line and confidence intervals - plot pred vs newdat -->
<!--   lines(pred$pred, newdat$log_abund, lwd = 2, col = 1) -->
<!--   lines(pred$ci.lb, newdat$log_abund, lwd = 1, lty = 2, col = 1) -->
<!--   lines(pred$ci.ub, newdat$log_abund, lwd = 1, lty = 2, col = 1) -->

<!--   legend("bottomright", title = "slope", -->
<!--          fill = viridis(5), -->
<!--          legend = signif(seq(min(dat$slope), max(dat$slope), length.out = 5), 2), -->
<!--          bty = "n", cex = .8) -->

<!--   # Add p-value text -->
<!--   text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]),  -->
<!--        y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]),   -->
<!--        labels = p_text, pos = 4, cex = 0.9, col = "darkred") -->
<!-- } -->

<!-- # Master plotting function for all scenario plots (4 plot types per scenario) -->
<!-- plot_all_scenarios <- function(scenario_list, scenario_names,  -->
<!--                               ylim_sr = c(40,100)) { -->
<!--   n_scenarios <- length(scenario_list) -->

<!--   # For each scenario, create all 4 plot types -->
<!--   for(i in 1:n_scenarios) { -->
<!--     # Set up 2x2 grid for each scenario with main title -->
<!--     # par(mfrow = c(2, 2), mar = c(4,4,3,2), oma = c(0, 0, 2, 0))       # change this for single or mulit-panel plots -->
<!--     par(mfrow = c(1, 1), mar = c(6,4,3,2), oma = c(0, 0, 2, 0))       # change this for single or mulit-panel plots -->

<!--     # Main analysis plots -->
<!--     plot_sr_slope(scenario_list[[i]], scenario_names[i], ylim_sr) -->
<!--     plot_abund_slope(scenario_list[[i]], scenario_names[i]) -->
<!--     plot_sr_cvmc(scenario_list[[i]], scenario_names[i], ylim_sr) -->
<!--     plot_sr_meanmc(scenario_list[[i]], scenario_names[i], ylim_sr) -->

<!--     # Add main title for the entire 4-panel plot -->
<!--     mtext(scenario_names[i], outer = TRUE, cex = 1.5, font = 2) -->
<!--   } -->
<!-- } -->
<!-- ``` -->

<!-- ```{r} -->
<!-- plot_all_scenarios(list(res_all), "", -->
<!--                    ylim_sr = c(40,100)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- plot_sr_meanmc(dat = res_all, tag = "") -->
<!-- ``` -->

```{r}
metamod <- readRDS(paste0(root, "local/runs/plot_sr-params/metafor/fix-PL-P-pDC_metamodMax.rds"))
# names(metamod)
# 
# plot(metamod$`P1-L5-C1_N0-L20-C1`)
```


```{r}
# pdf(paste0(root, "local/figures/plot_sr-params/diagnostics.pdf"), width = 5.3, height = 6, onefile = TRUE, useDingbats = FALSE)
plot(metamod$`P1-L5-C1_N1-L20-C5`, qqplot = TRUE)
# dev.off()
```
```{r}
# pdf(paste0(root, "local/figures/plot_sr-params/diagnostics_abund.pdf"), width = 4, height = 4.2, onefile = TRUE, useDingbats = FALSE)
plot(datmetaRan$ranCon$vi ~ datmetaRan$ranCon$abund,
     xlab="species abundance", ylab="standard error of mean stabilizing CDD (%)")
# dev.off()
```




