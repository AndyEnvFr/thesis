---
title: "PhyloSim Changes"
author: "A.I."
format:
  html:
    number-sections: true
editor: visual
---

```{r}
#| warning: false
library(PhyloSim)
library(parallel)
library(dplyr)
library(tidyverse)
library(lattice)
library(ggplot2)
library(metafor)
library(MASS)
library(viridis)
# root <- "~/Uni/Master/MA/" # work from local machine
root <- "~/cyber_synch/" # work from uni bayreuth server
```

Data is portioned in 3 50-fold-batches for better handling. Therefore, the analysis is repeated three times ranRuns\_\[i,ii,iii\].rds

## Data preparation

```{r}
#| eval: false

runsRaw  <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranRuns_i.rds"))
```

```{r}
#| eval: false

# get conspecific neighbors and proper naming
# runsRaw  <- getConNeigh(runsRaw, radius = 5)
```

```{r}
# make the runs more slim
runsRaw <- lapply(runsRaw, function(x){
  x$Output <- x$Output[101:200]
  x$Model$runs <- x$Model$runs[101:200]
  return(x)
})
```

```{r}
namesShort <- names(runsRaw) %>%
  stringr::str_remove("_disp.+") %>% 
  stringr::str_replace("Cut", "-C") %>% 
  stringr::str_replace("Cut", "-C") %>% 
  stringr::str_replace("pdd", "P") %>% 
  stringr::str_replace("ndd", "N") %>% 
  stringr::str_replace_all("Var", "-L") %>% 
  stringr::str_replace_all("\\d+\\.\\d{5,}", function(x) substr(x, 1, 6))
```

```{r}
names(runsRaw) <- namesShort
class(runsRaw) <- "PhylosimList"
```

```{r}
S <- getSpecTime(runsRaw, plot = TRUE)
```

Next, we convert the matrix data into tabular data. With the argument detailedParams we include the parameter settings a seperate cols. We save the tabular data.

```{r}
#| eval: false

# convert matrices to tabular data. This is done parallel, as it takes longer
cl <- makeCluster(50)
clusterExport(cl, c("getMatToTab", "runsRaw"))
tab <- parLapply(cl = cl, X = runsRaw, fun = function(x) getMatToTab(x, detailedParams = TRUE))
stopCluster(cl)


# saveRDS(tab, paste0(root, "/local/runs/mstr/20250903/ranTab_iii.rds"))
```

```{r}
tab <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranTab_iii.rds"))
```

```{r}
# keep only first timespot in census

cores <- length(tab)
cl <- makeCluster(25)

clusterEvalQ(cl, {
  library(dplyr)
})

tabS <- parLapply(cl, tab, function(x) {
  x %>%
    filter(abund > 100) %>%
    mutate(specIdCen = paste0(specId, census)) %>%
    select(-indId)
})

stopCluster(cl)
```

### Metafor analysis: correcting for uncertainty

```{r}
#| eval: false

cl <- makeCluster(25)

mcS_err <- parLapply(cl, tabS, function(x) {
  specIDs <- unique(x$specIdCen)
  res <- vector("list", length(specIDs))
  
  i <- 1
  for (sID in specIDs) {
    dat <- x[x$specIdCen == sID, ]
    mod <- glm(mortNextGen ~ con, data = dat, family = binomial())
    sfm <- summary(mod)$coefficients
    vc <- vcov(mod)[c("(Intercept)", "con"), c("(Intercept)", "con")]

    mort0 <- plogis(coef(mod)[1])
    mort1 <- plogis(coef(mod)[1] + coef(mod)[2])
    
    res[[i]] <- list(
      specId = sID,
      abund = dat$abund[1],
      mort_change = mort1 - mort0,
      coef = coef(mod)[c(1,2)],
      vcov = vc
    )
    i <- i + 1
  }
  return(res)
})

# Stop the cluster
stopCluster(cl)
```

## compute variance of the marginal effect through a "posterior" simulation

```{r}
#| eval: false

cl <- makeCluster(25)
mcS_err_sim <- parLapply(cl, mcS_err, function(x){
  lapply(x, function(y){
    sim <- MASS::mvrnorm(n = 100, mu = c(y$coef[1], y$coef[2]), Sigma = y$vcov)
    mort0 <- plogis(sim[, 1])
    mort1 <- plogis(sim[, 1] + sim[, 2])
    mort_diff <- mort1 - mort0
    
    return(data.frame(
      abund = y$abund,
      specId = y$specId,
      mean = mean(mort_diff),
      se = sd(mort_diff),
      ci_low = quantile(mort_diff, 0.025),
      ci_high = quantile(mort_diff, 0.975)
    ))
  })
})
# Stop the cluster
stopCluster(cl)
```

## unlist inner lists and add log abund

```{r}
#| eval: false

m4 <- lapply(mcS_err_sim, function(group) {
  do.call(rbind, group)
})

m4 <- lapply(m4, function(group) {
  row.names(group) <- NULL
  group <- group %>% 
    mutate(log_N = log(abund))
  return(group)
})
```

## fitting model

```{r}
#| eval: false

dat_meta <- lapply(m4, function(x) {
  escalc(measure = "GEN", yi = mean, sei = se, slab = specId, data = x)
})
```

```{r}
#| eval: false

# # Detect available cores and create a cluster
# cl <- makeCluster(length(dat_meta))
# 
# # Export needed objects and packages to the workers
# clusterExport(cl, varlist = c("dat_meta"), envir = environment())
# 
# # Run in parallel
# metamod <- parLapply(cl, dat_meta, function(x) {
#   metafor::rma(
#     yi = yi,
#     vi = vi,
#     mods = ~ log_N,
#     method = "REML",
#     data = x
#   )
# })
# 
# # Stop cluster
# stopCluster(cl)
# 
# names(metamod) <- namesShort
```

```{r}
cl <- makeCluster(length(dat_meta))
clusterExport(cl, varlist = c("dat_meta"), envir = environment())

metamod <- parLapply(cl, dat_meta, function(x) {
  tryCatch({
    metafor::rma(
      yi = yi,
      vi = vi,
      mods = ~ log_N,
      method = "REML",
      data = x
    )
  }, error = function(e) {
    return(NULL)  # Return NULL for failed models
  })
})

stopCluster(cl)

# Remove NULL elements and keep names aligned
failed_indices <- sapply(metamod, is.null)
namesShort <- names(metamod)
metamod <- metamod[!failed_indices]
names(metamod) <- namesShort[!failed_indices]

# Report which models failed
if(any(failed_indices)) {
  cat("Failed models:", paste(namesShort[failed_indices], collapse = ", "), "\n")
}
```

```{r}

# deleting one scenario

saveRDS(dat_meta, paste0(root, "/local/runs/mstr/20250903/ranDatmetaMax_iii.rds"))
saveRDS(metamod, paste0(root, "/local/runs/mstr/20250903/ranMetamodMax_iii.rds"))


# metamod <- readRDS(paste0(root, "..."))
# dat_meta <- readRDS(paste0(root, "..."))
```

## predictions

### log_N

```{r}
## --- build predictions (as you had) ---
pred <- lapply(dat_meta, function(x){
  expand_grid(log_N = seq(min(x$log_N, na.rm = TRUE),
                          max(x$log_N, na.rm = TRUE),
                          length.out = 1000))
})
pred <- lapply(pred, function(x){
  x$abund <- exp(x$log_N)
  x
})
pred <- lapply(seq_along(pred), function(i){
  x <- pred[[i]]
  y <- metamod[[i]]
  cbind(x, predict(object = y, newmods = x$log_N))
})
names(pred) <- namesShort   # <- your vector like the one you listed

## --- FIXED helper: parse P, PL, C from scenario name ---
extract_params <- function(nm) {
  # expect "P0.2-L20-C1_N1-L5-C1"
  # Split on underscore and take first part
  lhs <- sub("_.*", "", nm)                 # "P0.2-L20-C1"
  
  # Extract P, PL (L value), and C from first part
  P  <- as.numeric(sub("P([0-9.]+)-.*", "\\1", lhs))
  PL <- as.numeric(sub(".*-L([0-9.]+)-.*", "\\1", lhs))
  C  <- as.numeric(sub(".*-C([0-9.]+)$", "\\1", lhs))
  
  data.frame(P = P, PL = PL, C = C)
}

## --- bind list to df with parsed params ---
pred_df <- do.call(rbind, lapply(seq_along(pred), function(i) {
  df <- pred[[i]]
  pars <- extract_params(names(pred)[i])
  df$scenario <- names(pred)[i]
  df$P  <- pars$P
  df$PL <- pars$PL
  df$C  <- pars$C
  df
}))

## --- normalize predict() columns ---
if ("pred" %in% names(pred_df))   names(pred_df)[names(pred_df)=="pred"]   <- "fitted"
if ("fit"  %in% names(pred_df))   names(pred_df)[names(pred_df)=="fit"]    <- "fitted"
if ("ci.lb" %in% names(pred_df))  pred_df$ci_lower <- pred_df$ci.lb
if ("ci.ub" %in% names(pred_df))  pred_df$ci_upper <- pred_df$ci.ub

## --- null model (overlay on every plot) ---
null_nameC1 <- "P0-L20-C1_N1-L5-C1"
if (null_nameC1 %in% pred_df$scenario) {
  null_dataC1 <- pred_df[pred_df$scenario == null_nameC1, ]
} else {
  null_dataC1 <- NULL
}

null_nameC3 <- "P0-L20-C3_N1-L5-C1"
if (null_nameC3 %in% pred_df$scenario) {
  null_dataC3 <- pred_df[pred_df$scenario == null_nameC3, ]
} else {
  null_dataC3 <- NULL
}

null_nameC5 <- "P0-L20-C5_N1-L5-C1"
if (null_nameC5 %in% pred_df$scenario) {
  null_dataC5 <- pred_df[pred_df$scenario == null_nameC5, ]
} else {
  null_dataC5 <- NULL
}

## --- build separate plots per (PL, C), lines = P levels ---
library(ggplot2)

# common axes
x_range <- range(pred_df$abund[pred_df$abund > 0 & is.finite(pred_df$abund)], na.rm = TRUE)
y_range <- range(c(pred_df$ci_lower, pred_df$ci_upper), na.rm = TRUE)

# order P nicely for legend
pred_df$P_fac <- factor(pred_df$P, levels = sort(unique(pred_df$P)))

combos <- unique(pred_df[c("PL","C")])
combos <- combos[order(combos$PL, combos$C), ]

plots_list <- vector("list", nrow(combos))
names(plots_list) <- paste0("PL", combos$PL, "_C", combos$C)

for (i in seq_len(nrow(combos))) {
  pl_i <- combos$PL[i]
  c_i  <- combos$C[i]
  dat  <- subset(pred_df, PL == pl_i & C == c_i)
  if (nrow(dat) == 0) next

  p <- ggplot()

  # add null only if C == 1
  if (c_i == 1 & !is.null(null_dataC1)) {
    p <- p +
      geom_ribbon(data = null_dataC1,
                  aes(x = abund, ymin = ci_lower, ymax = ci_upper),
                  alpha = 0.15, fill = "grey50") +
      geom_line(data = null_dataC1,
                aes(x = abund, y = fitted),
                linetype = "dashed", size = 1.1, color = "black", alpha = 0.9)
  }
  # add null only if C == 3
  if (c_i == 3 & !is.null(null_dataC3)) {
    p <- p +
      geom_ribbon(data = null_dataC3,
                  aes(x = abund, ymin = ci_lower, ymax = ci_upper),
                  alpha = 0.15, fill = "grey50") +
      geom_line(data = null_dataC3,
                aes(x = abund, y = fitted),
                linetype = "dashed", size = 1.1, color = "black", alpha = 0.9)
  }
  # add null only if C == 5
  if (c_i == 5 & !is.null(null_dataC5)) {
    p <- p +
      geom_ribbon(data = null_dataC5,
                  aes(x = abund, ymin = ci_lower, ymax = ci_upper),
                  alpha = 0.15, fill = "grey50") +
      geom_line(data = null_dataC5,
                aes(x = abund, y = fitted),
                linetype = "dashed", size = 1.1, color = "black", alpha = 0.9)
  }

  # treatment lines
  p <- p +
    geom_line(data = dat, aes(x = abund, y = fitted, color = P_fac), size = 1.2) +
    scale_x_log10(limits = x_range, expand = expansion(mult = 0.02)) +
    labs(title = paste0("PL = ", pl_i, ", C = ", c_i,
                        "   (P-lines: ", length(unique(dat$P)), ")"),
         x = "Abundance per Census",
         y = "Mortality Change",
         color = "P") +
    theme_minimal(base_size = 12) +
    theme(legend.position = "bottom",
          plot.title = element_text(size = 14, hjust = 0.5))

  # set y-range depending on C
  if (c_i == 1) {
    p <- p + coord_cartesian(ylim = c(-0.005, 0.01))
  } else if (c_i == 3) {
    p <- p + coord_cartesian(ylim = c(-0.0025, 0.0045))
  } else if (c_i == 5) {
    p <- p + coord_cartesian(ylim = c(-0.0005, 0.0012))
  }

  plots_list[[i]] <- p
}

# Print all plots
lapply(plots_list, print)
```

## save PDF

```{r}
# pdf(paste0(root, "local/figures/plot_sr-params/pddSlope.pdf"), width = 5, height = 5, onefile = TRUE, useDingbats = FALSE)
lapply(plots_list, print)   # each print() â†’ new page
# dev.off()
```

# compare correlation (slope) with max species abundance and SR

```{r}
dat_meta <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranDatmetaMax_iii.rds"))
metamod <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranMetamodMax_iii.rds"))
runs <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranRuns_iii.rds"))

pred <- lapply(dat_meta, function(x){
  expand_grid(log_N = seq(min(x$log_N, na.rm = TRUE),
                          max(x$log_N, na.rm = TRUE),
                          length.out = 1000))
})
pred <- lapply(pred, function(x){
  x$abund <- exp(x$log_N)
  x
})
pred <- lapply(seq_along(pred), function(i){
  x <- pred[[i]]
  y <- metamod[[i]]
  cbind(x, predict(object = y, newmods = x$log_N))
})
names(pred) <- names(metamod)
```

```{r}
names(runs) <- names(dat_meta)
srRaw <- getSpecTime(runs, plot = FALSE)

# Get slopes
slope <- map_dbl(metamod, ~ coef(.x)[2]) %>%
  enframe(name = "param", value = "slope")

# Get standard error of slopes
seSlope <- map_dbl(metamod, ~ se(.x)[2]) %>%
  enframe(name = "param", value = "seSlope")

# Get abundance (use max to exclude extreme values)
abund <- map_dbl(dat_meta, ~ max(.x$abund)) %>%
  enframe(name = "param", value = "abund")

# Get CV of predictions
cv <- map(pred, ~ {
  meanMC <- mean(.x$pred)
  sdMC <- sd(.x$pred)
  rangeMC <- diff(range(.x$pred))
  tibble(meanMC = meanMC, sdMC = sdMC, rangeMC = rangeMC, cvMC = sdMC / meanMC)
}) %>%
  bind_rows(.id = "param")

# Get species richness summary
sr <- map(srRaw, ~ {
  vals <- .x$spec_rich[99:200]
  tibble(
    meanSR = mean(vals),
    sdSR = sd(vals),
    medianSR = median(vals)
  )
}) %>%
  bind_rows(.id = "param") %>%
  mutate(medianSR = as.integer(medianSR))

# Combine all results
res <- list(slope, seSlope, sr, abund, cv) %>%
  reduce(left_join, by = "param") %>%
  mutate(abund = as.integer(abund))

# Filter by scenario types
scenario_types <- expand.grid(prefix = c("P", "N"), comp = paste0("C", 1:5), stringsAsFactors = FALSE)

res_scenarios <- map2(scenario_types$prefix, scenario_types$comp, ~ {
  pattern <- if (.x == "P") paste0(.x, ".*-", .y, "_") else paste0(.x, ".*-", .y, "$")
  res %>% filter(grepl(pattern, param))
}) %>%
  set_names(paste0(scenario_types$prefix, scenario_types$comp))
```

```{r}
# saveRDS(res, paste0(root, "/local/runs/mstr/20250903/ranResMax_iii.rds"))
```

```{r}
#| fig-width: 10
#| fig-height: 8

## ---- helper functions ----
pred_lm_log <- function(mod, newdata, k = 2) {
  pred <- predict(mod, newdata = newdata, se.fit = TRUE)
  fit <- exp(pred$fit)
  lo  <- exp(pred$fit - k*pred$se.fit)
  hi  <- exp(pred$fit + k*pred$se.fit)
  list(fit = fit, lo = lo, hi = hi)
}

# Helper function to format p-values
format_pvalue <- function(p) {
  if (p < 0.001) {
    return("p < 0.001")
  } else if (p < 0.01) {
    return(sprintf("p = %.3f", p))
  } else {
    return(sprintf("p = %.2f", p))
  }
}

# Unified function for species richness vs slope plot (WITH HORIZONTAL ERROR BARS)
plot_sr_slope <- function(dat, tag, ylim_sr = c(40,100)) {
  fm1 <- lm(meanSR ~ slope, data = dat)
  newdat <- data.frame(slope = seq(min(dat$slope), max(dat$slope), length = 100))
  predi <- predict(fm1, newdata = newdat, se.fit = TRUE)
  
  # Extract p-value
  p_val <- summary(fm1)$coefficients[2, 4]  # p-value for slope coefficient
  p_text <- format_pvalue(p_val)
  
  plot(dat$slope, dat$meanSR, ylim = ylim_sr, pch = 16, col = "blue",
       xlab = "slope", ylab = "mean species richness")
  points(dat$slope, dat$medianSR, pch = 16, col = "red")
  
  # Horizontal error bars for seSlope
  arrows(dat$slope - dat$seSlope, dat$meanSR, dat$slope + dat$seSlope, dat$meanSR,
         angle = 90, code = 3, length = 0.05)
  # Vertical error bars (existing)
  arrows(dat$slope, dat$meanSR - dat$sdSR, dat$slope, dat$meanSR + dat$sdSR,
         angle = 90, code = 3, length = 0.05)
  
  lines(newdat$slope, predi$fit, lwd = 2, col = 1)
  lines(newdat$slope, predi$fit - 2*predi$se.fit, lwd = 1, lty = 2, col = 1)
  lines(newdat$slope, predi$fit + 2*predi$se.fit, lwd = 1, lty = 2, col = 1)
  legend("topright", legend = c("mean SR", "median SR", "fitted lm", "CI"),
         pch = c(16,16,NA,NA), lty = c(NA,NA,1,2), col = c(4,2,1,1), bty = "n")
  
  # Add p-value text
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Unified function for abundance vs slope plot (WITH HORIZONTAL ERROR BARS)
plot_abund_slope <- function(dat, tag) {
  # Log-transform abundance (add 1 to avoid log(0))
  dat$log_abund <- log(dat$abund)
  # Fit linear model on log(abundance)
  fm <- lm(log_abund ~ slope, data = dat)
  # Prediction along slope range
  newdat <- data.frame(slope = seq(min(dat$slope), max(dat$slope), length = 100))
  pg <- pred_lm_log(fm, newdat, k = 2)
  # Extract p-value for slope
  p_val <- summary(fm)$coefficients[2, 4]
  p_text <- format_pvalue(p_val)
  # Plot log-transformed abundances
  plot(dat$slope, dat$log_abund, pch = 16, col = 1,
       xlab = "slope", ylab = "log(max abundance)")
  
  # Horizontal error bars for seSlope (NEW)
  arrows(dat$slope - dat$seSlope, dat$log_abund, dat$slope + dat$seSlope, dat$log_abund,
         angle = 90, code = 3, length = 0.05, col = 1)
  
  # Add fitted line and confidence intervals
  lines(newdat$slope, log(pg$fit), lwd = 2, col = 1)
  lines(newdat$slope, log(pg$lo), lwd = 1, lty = 2, col = 1)
  lines(newdat$slope, log(pg$hi), lwd = 1, lty = 2, col = 1)
  # Add legend
  legend("topleft", legend = c("fitted lm", "CI"), lty = c(1,2),
         col = c(1,1), bty = "n")
  # Add p-value text
  text(x = par("usr")[1] + 0.75*diff(par("usr")[1:2]),
       y = par("usr")[4] - 0.05*diff(par("usr")[3:4]),
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Unified function for species richness vs CV mortality change (unchanged)
plot_sr_cvmc <- function(dat, tag, ylim_sr = c(40,90)) {
  fm3 <- lm(meanSR ~ cvMC, data = dat)
  newdat <- data.frame(cvMC = seq(min(dat$cvMC), max(dat$cvMC), length = 100))
  pred <- predict(fm3, newdata = newdat, se.fit = TRUE)
  
  # Extract p-value
  p_val <- summary(fm3)$coefficients[2, 4]  # p-value for cvMC coefficient
  p_text <- format_pvalue(p_val)
  
  cols <- viridis(length(dat$slope))[rank(dat$slope)]
  plot(dat$cvMC, dat$meanSR, ylim = ylim_sr, pch = 16, col = cols,
       xlab = "CV of stabilizing CDD", ylab = "mean species richness")
  arrows(dat$cvMC, dat$meanSR - dat$sdSR, dat$cvMC, dat$meanSR + dat$sdSR,
         angle = 90, code = 3, length = 0.05, col = cols)
  lines(newdat$cvMC, pred$fit, lwd = 2, col = 1)
  lines(newdat$cvMC, pred$fit - 2*pred$se.fit, lwd = 1, lty = 2, col = 1)
  lines(newdat$cvMC, pred$fit + 2*pred$se.fit, lwd = 1, lty = 2, col = 1)
  legend("topright", title = "slope",
         fill = viridis(5),
         legend = signif(seq(min(dat$slope), max(dat$slope), length.out = 5), 2),
         bty = "n", cex = .8)
  
  # Add p-value text
  text(x = par("usr")[1] + 0.02 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Unified function for species richness vs mean stabilizing CDD (unchanged)
plot_sr_meanmc <- function(dat, tag, ylim_sr = c(40,90)) {
  fm4 <- lm(meanSR ~ meanMC, data = dat)
  newdat <- data.frame(meanMC = seq(min(dat$meanMC), max(dat$meanMC), length = 100))
  pred <- predict(fm4, newdata = newdat, se.fit = TRUE)
  
  # Extract p-value
  p_val <- summary(fm4)$coefficients[2, 4]  # p-value for log(meanMC) coefficient
  p_text <- format_pvalue(p_val)
  
  cols <- viridis(length(dat$slope))[rank(dat$slope)]
  plot(dat$meanMC, dat$meanSR, ylim = ylim_sr, pch = 16, col = cols,
       xlab = "mean stabilizing CDD (%)", ylab = "mean species richness")
    # Horizontal error bars for sdMC
  arrows(dat$meanMC - dat$sdMC, dat$meanSR, dat$meanMC + dat$sdMC, dat$meanSR,
         angle = 90, code = 3, length = 0.05)
  lines(newdat$meanMC, pred$fit, lwd = 2, col = 1)
  lines(newdat$meanMC, pred$fit - 2*pred$se.fit, lwd = 1, lty = 2, col = 1)
  lines(newdat$meanMC, pred$fit + 2*pred$se.fit, lwd = 1, lty = 2, col = 1)
  legend("bottomright", title = "slope",
         fill = viridis(5),
         legend = signif(seq(min(dat$slope), max(dat$slope), length.out = 5), 2),
         bty = "n", cex = .8)
  legend("topleft", legend = c("fitted lm", "CI"),
         lty = c(1,2), bty = "n")
  
  # Add p-value text
  text(x = par("usr")[1] + 0.75 * diff(par("usr")[1:2]), 
       y = par("usr")[4] - 0.05 * diff(par("usr")[3:4]), 
       labels = p_text, pos = 4, cex = 0.9, col = "darkred")
}

# Master plotting function for all scenario plots (4 plot types per scenario)
plot_all_scenarios <- function(scenario_list, scenario_names, 
                              ylim_sr = c(40,100)) {
  n_scenarios <- length(scenario_list)
  
  # For each scenario, create all 4 plot types
  for(i in 1:n_scenarios) {
    # Set up 2x2 grid for each scenario with main title
    par(mfrow = c(2, 2), mar = c(4,4,3,2), oma = c(0, 0, 2, 0))
    
    # Main analysis plots
    plot_sr_slope(scenario_list[[i]], scenario_names[i], ylim_sr)
    plot_abund_slope(scenario_list[[i]], scenario_names[i])
    plot_sr_cvmc(scenario_list[[i]], scenario_names[i], ylim_sr)
    plot_sr_meanmc(scenario_list[[i]], scenario_names[i], ylim_sr)
    
    # Add main title for the entire 4-panel plot
    mtext(scenario_names[i], outer = TRUE, cex = 1.5, font = 2)
  }
}

## ---- apply to scenarios C1-C5 ----
# Assuming you have data objects: resC1, resC2, resC3, resC4, resC5
scenario_dataP <- res_scenarios[str_detect(string = names(res_scenarios),pattern = "P")]
scenario_labelsP <- c("pDC = 1","pDC = 2", "pDC = 3","pDC = 4", "pDC = 5")
scenario_dataN <- res_scenarios[str_detect(string = names(res_scenarios),pattern = "N")]
scenario_labelsN <- c("nDC = 1","nDC = 2", "nDC = 3","nDC = 4", "nDC = 5")

# # Generate all plots for negative scenarios
# plot_all_scenarios(scenario_dataN, scenario_labelsN,
#                    ylim_sr = c(40,100))
# 
# # Generate all plots for positive scenarios (fixed label bug)
# plot_all_scenarios(scenario_dataP, scenario_labelsP,
#                    ylim_sr = c(40,100))

# Generate plot for combined data
plot_all_scenarios(list(res), "combined data", 
                   ylim_sr = c(40,100))
```

```{r}
# pdf(paste0(root, "local/figures/plot_sr-params/pddSupplPlots.pdf"), width = 10, height = 6.5, onefile = TRUE, useDingbats = FALSE)
    # Generate all plots for all scenarios with p-values
    # plot_all_scenarios(scenario_dataP, scenario_labelsP, 
    #                    ylim_sr = c(40,100), ylim_abund = c(0,15000))
    # plot_all_scenarios(scenario_dataN, scenario_labelsN, 
    #                    ylim_sr = c(40,100), ylim_abund = c(0,15000))
# dev.off()

```

#all results combined

```{r}
resi <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResMax_i.rds"))
resii <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResMax_ii.rds"))
resiii <- readRDS(paste0(root, "/local/runs/mstr/20250903/ranResMax_iii.rds"))

res_all <- rbind(resi,resii,resiii)
```

```{r}
#| fig-width: 10
#| fig-height: 10


# pdf(paste0(root, "local/figures/ran%ran_allMax.pdf"), width = 10, height = 6.5, onefile = TRUE, useDingbats = FALSE)
# Generate all plots for all scenarios with p-values
plot_all_scenarios(list(res_all), "",
                   ylim_sr = c(40,100))

# dev.off()
```

## mutlidemsional plots

```{r}
# Load required libraries
library(ggplot2)
library(dplyr)
library(stringr)
library(gridExtra)

# Assuming your data is in a dataframe called 'res'
# If not, load it first with: res <- read.csv("your_file.csv") or similar

# 1. Plot with meanSR vs slope, colored by int
plot1 <- ggplot(res_all, aes(x = slope, y = meanSR, color = int)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "Intercept") +
  labs(title = "Mean SR vs Slope (colored by intercept)",
       x = "Slope",
       y = "Mean SR") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 2. Plot with meanSR vs slope, colored by cvMC
plot2 <- ggplot(res_all, aes(x = slope, y = meanSR, color = cvMC)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "CV") +
  labs(title = "Mean SR vs Slope (colored by CV)",
       x = "Slope",
       y = "Mean SR") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# Extract parameters from the param column
# Parse the parameter string to extract P, L, C, N values
parse_params <- function(param_string) {
  # Extract P value and its L,C
  p_part <- str_extract(param_string, "P[0-9.]+\\-L[0-9.]+\\-C[0-9]+")
  n_part <- str_extract(param_string, "N[0-9.]+\\-L[0-9.]+\\-C[0-9]+")
  
  # Extract individual values
  P <- as.numeric(str_extract(str_extract(p_part, "P[0-9.]+"), "[0-9.]+"))
  PL <- as.numeric(str_extract(str_extract(p_part, "L[0-9.]+"), "[0-9.]+"))
  PC <- as.numeric(str_extract(str_extract(p_part, "C[0-9]+"), "[0-9]+"))
  
  N <- as.numeric(str_extract(str_extract(n_part, "N[0-9.]+"), "[0-9.]+"))
  NL <- as.numeric(str_extract(str_extract(n_part, "L[0-9.]+"), "[0-9.]+"))
  NC <- as.numeric(str_extract(str_extract(n_part, "C[0-9]+"), "[0-9]+"))
  
  return(data.frame(P = P, PL = PL, PC = PC, N = N, NL = NL, NC = NC))
}

# Apply the parsing function
parsed_params <- do.call(rbind, lapply(res_all$param, parse_params))
res_extended <- cbind(res_all, parsed_params)

# 3. Plot P vs N, colored by meanSR
plot3 <- ggplot(res_extended, aes(x = P, y = N, color = meanSR)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "Mean SR") +
  labs(title = "P vs N (colored by Mean SR)",
       x = "P parameter",
       y = "N parameter") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 4. Plot PL vs NL, colored by meanSR
plot4 <- ggplot(res_extended, aes(x = PL, y = NL, color = meanSR)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "Mean SR") +
  labs(title = "PL vs NL (colored by Mean SR)",
       x = "PL parameter",
       y = "NL parameter") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 5. Plot PC vs NC, colored by meanSR
plot5 <- ggplot(res_extended, aes(x = PC, y = NC, color = meanSR)) +
  geom_jitter(size = 3, alpha = 0.7, width = 0.2, height = 0.2) +
  scale_color_viridis_c(name = "Mean SR") +
  labs(title = "PC vs NC (colored by Mean SR)",
       x = "PC parameter",
       y = "NC parameter") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 6. NEW: Plot P vs PL, colored by meanSR
plot6 <- ggplot(res_extended, aes(x = P, y = PL, color = meanSR)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "Mean SR") +
  labs(title = "P vs PL (colored by Mean SR)",
       x = "P parameter",
       y = "PL parameter") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 7. NEW: Plot N vs NL, colored by meanSR
plot7 <- ggplot(res_extended, aes(x = N, y = NL, color = meanSR)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_viridis_c(name = "Mean SR") +
  labs(title = "N vs NL (colored by Mean SR)",
       x = "N parameter",
       y = "NL parameter") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# Display plots
print(plot1)
print(plot2)
print(plot3)
print(plot4)
print(plot5)
print(plot6)  # New plot
print(plot7)  # New plot

# If you want to save all plots in one figure
combined_plot <- grid.arrange(
  plot3, plot4, plot5,plot6, plot7,
  ncol = 3, nrow = 2,
  top = "Parameter Relationships"
)

# Save plots if needed
# ggsave(paste0(root, "local/figures/ran/meanSR_slope_int_allMax.pdf"), plot1, width = 10, height = 6, dpi = 300)
# ggsave(paste0(root, "local/figures/ran/meanSR_slope_CV_allMax.pdf"), plot2, width = 10, height = 6, dpi = 300)
# ggsave(paste0(root, "local/figures/ran/meanSR_params_allMax.pdf"), combined_plot, width = 15, height = 10, dpi = 300)

```
